<h2 id="静态配置文件（setting-py）"><a href="#静态配置文件（setting-py）" class="headerlink" title="静态配置文件（setting.py）"></a>静态配置文件（setting.py）</h2><h3 id="静态文件路径"><a href="#静态文件路径" class="headerlink" title="静态文件路径"></a>静态文件路径</h3><p>通过url找到静态文件</p>
<ul>
<li><p>STATIC_URL=’/static/‘</p>
<p>指定访问静态文件时需要通过/static/xxx </p>
</li>
</ul>
<p>​    静态文件的存储路径 STATICFILES_DIRS（在服务器端的存储位置）</p>
<pre><code class="py"># file: setting.py
STATICFILES_DIRS = (
    os.path.join(BASE_DIR,&quot;static&quot;),
)
</code></pre>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><ol>
<li><p>用命令startapp创建应用文件夹</p>
<pre><code class="bash">python3 manage.py startapp music
</code></pre>
</li>
<li><p>在settings.py的INSTALLED_APPS列表中配置安装此应用</p>
</li>
</ol>
<p>​    配置样例：</p>
<pre><code class="py">INSTALLED_APPS = [
    # ....
    &#39;user&#39;, #用户信息模块
    ‘music’， #音乐模块
]
</code></pre>
<h2 id="分布式路由"><a href="#分布式路由" class="headerlink" title="分布式路由"></a>分布式路由</h2><p>主路由配置文件（urls.py）可以不处理用户具体路由 ，主路由配置文件可以做请求的分发（分布式请求处理）。</p>
<p><img src="/.%5CImage%5Cimage-20211124220829565.png" alt="image-20211124220829565"></p>
<h3 id="配置分布式路由"><a href="#配置分布式路由" class="headerlink" title="配置分布式路由"></a>配置分布式路由</h3><ol>
<li>调用include函数</li>
</ol>
<p>语法：<code>include(&#39;app名字.url模块名&#39;)</code></p>
<p>作用：将当前路由转到各个应用的路由配置文件urlpatterns进行分布式处理 </p>
<ol start="2">
<li>应用下配置urls.py</li>
</ol>
<p>应用下手动创建urls.py文件，内容结构同路由完全一样</p>
<h2 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h2><p>作用：负责跟数据库之间进行通信</p>
<ul>
<li>Django配置mysql</li>
</ul>
<p>​    <code>pip3 install mysqlclient</code></p>
<ul>
<li><p>创建数据库</p>
</li>
<li><p>修改数据库配置信息</p>
<p>默认配置：</p>
</li>
</ul>
<p><img src="/.%5CImage%5Cimage-20211124222701715.png" alt="image-20211124222701715"></p>
<p>修改为：</p>
<pre><code class="py">DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;:&#39;django.db.backend&#39;,
        &#39;NAME&#39;: &#39;q0o0p&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;:&#39;123456&#39;,
        &#39;HOST&#39;: &#39;127.0.0.1&#39;,
        &#39;PORT&#39;:&#39;3306&#39;
    }
}
</code></pre>
<p>ENGINE  ：指定数据库存储引擎</p>
<pre><code class="py">&#39;djang.db.backends.mysql&#39;
&#39;djang.db.backends.sqlite3&#39;
&#39;djang.db.backends.oracle&#39;
&#39;djang.db.backends.postgresql&#39;
</code></pre>
<h3 id="什么是模型层"><a href="#什么是模型层" class="headerlink" title="什么是模型层"></a>什么是模型层</h3><p>模型层是由<code>django.db.models.Model</code>  派生出的子类，一个模型类代表数据库的一张数据表，模型类中每一个类属性都代表数据库中的一个字段。模型是数据交互的接口，是表示和操作数据库的方法。</p>
<h3 id="ORM框架-Object-Relational-Mapping"><a href="#ORM框架-Object-Relational-Mapping" class="headerlink" title="ORM框架(Object Relational Mapping)"></a>ORM框架(Object Relational Mapping)</h3><p>对象关系映射，允许使用类和对象对数据库进行操作，从而避免通过SQL语句操作数据库</p>
<ul>
<li><p>作用</p>
<ol>
<li>建立模型类和表之间对应的关系，允许通过对象操作数据库。</li>
<li>根据设计模型类生成数据库表格。</li>
<li>通过简单的配置就可以进行数据库的切换。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li><p>对应复杂业务使用成本较高。</p>
</li>
<li><p>根据对象的操作转换成sql语句，根据查询的结果转换成对象，在映射过程中有性能损失。</p>
<table>
<thead>
<tr>
<th>ORM</th>
<th>DB</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>数据表</td>
</tr>
<tr>
<td>对象</td>
<td>数据行</td>
</tr>
<tr>
<td>属性</td>
<td>字段</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ul>
<p>例子：</p>
<p>models.py</p>
<pre><code class="py">from django.db imoport models
class Book(models.Model):
    title = models.CharField(&#39;书名&#39;，max_length=50,default=&#39;&#39;)
    price = models.DecimalField(&#39;价格&#39;,max_digits=7, decimal_places=2)
</code></pre>
<ol start="3">
<li><p>数据库迁移</p>
<p>Django同步对模型所做更改（添加字段，删除模型等）到数据库模式的方式。</p>
<ul>
<li>生成迁移文件</li>
</ul>
<p><code>python3 manage.py makemigrations</code></p>
<ul>
<li>执行迁移脚本</li>
</ul>
<p><code>python3 mangage.py migrate</code></p>
<p>将每个应用下的migrations目录中的中间文件同步回数据库。</p>
</li>
</ol>
<h3 id="模型类创建"><a href="#模型类创建" class="headerlink" title="模型类创建"></a>模型类创建</h3><p>先创建应用: <code>python manage.py startapp commands</code></p>
<p>INSTALLED_APPS 中添加应用名称</p>
<p>在应用下的commands/models.py中编写模型类</p>
<pre><code class="py">from django.db import models
class 模型类名（models.Model):
    字段名 = models.字段类型(字段选项)
</code></pre>
<p><img src="/.%5CImage%5Cimage-20211125213750316.png" alt="image-20211125213750316"></p>
<h3 id="模板类字段类型"><a href="#模板类字段类型" class="headerlink" title="模板类字段类型"></a>模板类字段类型</h3><ul>
<li>BooleanField()</li>
</ul>
<p>数据库类型：tinyint(1)</p>
<p>编程语言中：True 或 False</p>
<p>数据库中：1或0</p>
<ul>
<li>CharField()</li>
</ul>
<p>数据库类型：varchar</p>
<p>注意：<code>必须要指定max_length参数值</code></p>
<ul>
<li>DateField()</li>
</ul>
<p>数据库类型：date</p>
<p>参数：auto_now（每次保存对象时，自动设置该字段为当前时间，使用True 或False）auto_now_add（第一次创建时自动设置当前时间，使用True或False）default（设置当前时间，字符串格式：‘2022-1-1’）</p>
<ul>
<li>DecimalField()</li>
</ul>
<p>数据库类型：decimal(x.y)    </p>
<p>使用小数，参数：max_digits（位数总数，包括小数点后的位数，大于等于decimal_places）decimal_places（小数点后的数字数量）</p>
<ul>
<li>EmailField()</li>
</ul>
<p>数据库类型：varchar</p>
<p>使用字符串</p>
<ul>
<li>IntegerField()</li>
</ul>
<p>数据库类型：int</p>
<p>整数</p>
<ul>
<li>ImageField()</li>
</ul>
<p>数据库类型：varchar(100)</p>
<p>保存图片路径，使用字符串</p>
<ul>
<li>TextField()</li>
</ul>
<p>数据库类型：longtext</p>
<p>表示不定长的字符数据</p>
<h3 id="模型类字段选项"><a href="#模型类字段选项" class="headerlink" title="模型类字段选项"></a>模型类字段选项</h3><p>允许出现多个字段选项，多个选项之间使用<code>,</code> 隔开</p>
<ul>
<li>primary_key</li>
</ul>
<p>设置为True ，表示主键。</p>
<ul>
<li>blank</li>
</ul>
<p>True，字段为空；Flase：该字段必须填写。</p>
<ul>
<li>null</li>
</ul>
<p>True：允许为空，默认为False。</p>
<ul>
<li>default</li>
</ul>
<p>设置所在列的默认值。</p>
<ul>
<li>db_index</li>
</ul>
<p>True：表示该列添加索引。</p>
<ul>
<li>unique</li>
</ul>
<p>True：值必须唯一，不能重复出现。</p>
<ul>
<li>db_column</li>
</ul>
<p>指定列名称，不指定则采用属性名作为列名。</p>
<ul>
<li>verbose_name</li>
</ul>
<p>设置此字段在admin界面上显示名称。</p>
<p>注意：<code>修改过字段选项均要执行：python manage.py makemigrations   python manage.py migrate</code></p>
<h3 id="模型类Meta类"><a href="#模型类Meta类" class="headerlink" title="模型类Meta类"></a>模型类Meta类</h3><p>修改表名</p>
<pre><code class="py">class Meta:
    db_table = &#39;q0o0p&#39;
</code></pre>
<h3 id="常见问题处理"><a href="#常见问题处理" class="headerlink" title="常见问题处理"></a>常见问题处理</h3><ol>
<li>当模型类添加一个字段后可能报错</li>
</ol>
<p>原理：数据库不知道原来已有数据对新字段如何赋值。</p>
<p>解决方案：添加新字段时，务必添加<code>default</code> 默认值（default=xxx）。</p>
<ol start="2">
<li>数据库的迁移文件混乱的解决办法</li>
</ol>
<p>数据库中migrations表记录了migrate的全过程，项目各应用中的migrate文件应与之对应，否则会报错。</p>
<p>解决方案：删除里所有的000?<em>xxx.py(init</em>__.py除外)之外还要删除数据库 <code>drop database mywebdb;</code></p>
<h2 id="ORM操作"><a href="#ORM操作" class="headerlink" title="ORM操作"></a>ORM操作</h2><p>CRUD包括增删改查（Create、Read、Update、Delete）</p>
<h3 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h3><ul>
<li>管理器对象</li>
</ul>
<p>每个继承自models.Model的模型类，都会有objects对象被同样继承下来，这个对象叫管理器对象。</p>
<p>数据库增删改查可以通过模型的管理器实现。</p>
<p>方案一：</p>
<pre><code class="py">class MyModel(models.Model):
    ...
MyModel.objects.create(属性=值，属性=值) # objects 是管理器对象
</code></pre>
<p>方案二：</p>
<pre><code class="py">obj = MyModel(属性=值)
obj.属性=值
obj.save()
</code></pre>
<ul>
<li>Django shell</li>
</ul>
<p>项目代码发生变化时，重新进入Django shell</p>
<pre><code class="bash">python manage.py shell
</code></pre>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>通过MyModel.objects 管理器方法调用查询方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
<th>对应的数据库语句</th>
</tr>
</thead>
<tbody><tr>
<td>all()</td>
<td>查询全部记录，返回QuerySet查询对象</td>
<td>select * from tabel</td>
</tr>
<tr>
<td>get()</td>
<td>查询符合条件的单一记录</td>
<td></td>
</tr>
<tr>
<td>filter()</td>
<td>查询符合条件的多条记录</td>
<td></td>
</tr>
<tr>
<td>exclude()</td>
<td>查询符合条件之外的全部记录</td>
<td></td>
</tr>
<tr>
<td>values(‘列1’，‘列2’)</td>
<td>查询部分列的数据并返回，返回格式为字典类型</td>
<td>select 列1，列2 from xxx</td>
</tr>
<tr>
<td>order_by()</td>
<td>会使用SQL语句的ORDER BY子句对查询结果进行根据某个字段选择性的进行排序（默认升序，降序需在列前添加<code>-</code></td>
<td></td>
</tr>
</tbody></table>
<pre><code class="py">from commands.models import Command
commands = Command.objects.all()
for command in commands:
    print(&#39;命令&#39;，command.command,&#39;命令信息&#39;,command.info)
</code></pre>
