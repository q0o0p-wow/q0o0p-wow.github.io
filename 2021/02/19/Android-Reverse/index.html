<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Android逆向初级篇(一) | q0o0p</title><meta name="keywords" content="Android,reverse"><meta name="author" content="q0o0p"><meta name="copyright" content="q0o0p"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="App加壳和脱壳常见的壳通常是看lib文件夹下so库特征，以下是市面上常见的不同厂商对APP的加固特征：爱加密：libexec.so,libexecmain.so，ijiami.dat梆梆： libsecexe.so,libsecmain.so , libDexHelper.so libSecShell.so360：libprotectClass.so,libjiagu.so，libji">
<meta property="og:type" content="article">
<meta property="og:title" content="Android逆向初级篇(一)">
<meta property="og:url" content="https://github.com/q0o0p-wow/q0o0p-wow.github.io/2021/02/19/Android-Reverse/index.html">
<meta property="og:site_name" content="q0o0p">
<meta property="og:description" content="App加壳和脱壳常见的壳通常是看lib文件夹下so库特征，以下是市面上常见的不同厂商对APP的加固特征：爱加密：libexec.so,libexecmain.so，ijiami.dat梆梆： libsecexe.so,libsecmain.so , libDexHelper.so libSecShell.so360：libprotectClass.so,libjiagu.so，libji">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/q0o0p-wow/q0o0p-wow.github.io/img/7.jpg">
<meta property="article:published_time" content="2021-02-19T15:23:23.000Z">
<meta property="article:modified_time" content="2021-09-17T08:36:24.210Z">
<meta property="article:author" content="q0o0p">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="reverse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/q0o0p-wow/q0o0p-wow.github.io/img/7.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/q0o0p-wow/q0o0p-wow.github.io/2021/02/19/Android-Reverse/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android逆向初级篇(一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-17 16:36:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <link rel="stylesheet" href="/live2d-widget/waifu.css"> <link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">60</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">q0o0p</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Android逆向初级篇(一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-02-19T15:23:23.000Z" title="Created 2021-02-19 23:23:23">2021-02-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-09-17T08:36:24.210Z" title="Updated 2021-09-17 16:36:24">2021-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/tools/">tools</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">14.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>50min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android逆向初级篇(一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container">

<script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script>


<h1 id="App加壳和脱壳"><a href="#App加壳和脱壳" class="headerlink" title="App加壳和脱壳"></a>App加壳和脱壳</h1><h2 id="常见的壳"><a href="#常见的壳" class="headerlink" title="常见的壳"></a>常见的壳</h2><p>通常是看lib文件夹下so库特征，以下是市面上常见的不同厂商对APP的加固特征：<br>爱加密：libexec.so,libexecmain.so，ijiami.dat<br>梆梆： libsecexe.so,libsecmain.so , libDexHelper.so libSecShell.so<br>360：libprotectClass.so,libjiagu.so，libjiagu_art.so，libjiagu_x86.so<br>百度：libbaiduprotect.so<br>腾讯：libshellx-2.10.6.0.so，libBugly.so，libtup.so, libexec.so，libshell.so，stub_tengxun<br>网易易盾：libnesec.so<br>娜迦： libchaosvmp.so , libddog.solibfdog.so<br>通付盾：libegis.so<br>网秦：libnqshield.so</p>
<h3 id="脱壳机制原理"><a href="#脱壳机制原理" class="headerlink" title="脱壳机制原理"></a>脱壳机制原理</h3><p>smali层：只做了一些简单的混淆<br>Native 层：<br>和如下内容相关<br>各种so库<br>比如libdvm.so<br>对应着内部函数调用：<br>.init<br>.init_array<br>JNI_Onload<br>分析修改ELF头信息<br>sub_xxx函数<br>比如：sub_78614CD0<br>R2寄存器<br>最后分析出：<br>ClassLoader<br>loadDex<br>multidex<br>新一代的360加固保：用art模式+dex2oat相关机制，或许可以破解</p>
<p>腾讯乐固加密后的目录结构和典型内容<br>腾讯的乐固legu加密加壳后的apk，去用apktool反编译后，得到的jar包的目录结构是：<br>com.tencent.bugly<br>com.tencent.bugly.legu<br>crashreport<br>proguard<br>com.tencent.StubShell<br>TxAppEntry</p>
<p>详细的目录结构和文件是：<br>➜  tencent ll<br>total 0<br>drwxr-xr-x  12 crifan  staff   384B  3 14 13:39 StubShell<br>drwxr-xr-x   3 crifan  staff    96B  3 14 13:39 bugly<br>➜  tencent tree .<br>.<br>├── StubShell<br>│   ├── SystemClassLoaderInjector.smali<br>│   ├── SystemInfoException.smali<br>│   ├── TxAppEntry.smali<br>│   ├── TxReceiver.smali<br>│   ├── XposedCheck.smali<br>│   ├── ZipUtil.smali<br>│   ├── a.smali<br>│   ├── b.smali<br>│   ├── c.smali<br>│   └── d.smali<br>└── bugly<br>    └── legu<br>        ├── Bugly.smali<br>        ├── BuglyStrategy$a.smali<br>        ├── BuglyStrategy.smali<br>        ├── CrashModule.smali<br>        ├── a.smali<br>        ├── b.smali<br>        ├── crashreport<br>        │   ├── BuglyHintException.smali<br>        │   ├── BuglyLog.smali<br>        │   ├── CrashReport$CrashHandleCallback.smali<br>        │   ├── CrashReport$UserStrategy.smali<br>        │   ├── CrashReport.smali<br>        │   。。。<br>        │   └── inner<br>        │       └── InnerAPI.smali<br>        └── proguard<br>            ├── a.smali<br>            ├── 。。。<br>            └── z.smali<br>➜  lib tree .<br>.<br>├── arm64-v8a<br>│   ├── libBugly.so<br>│   ├── libgifimage.so<br>│   ├── libimagepipeline.so<br>│   ├── libjcore119.so<br>│   ├── libshella-2.9.1.2.so<br>│   └── libstatic-webp.so<br>├── armeabi<br>│   ├── libBugly.so<br>│   ├── libgifimage.so<br>│   ├── libimagepipeline.so<br>│   ├── libjcore119.so<br>│   ├── libshella-2.9.1.2.so<br>│   ├── libstatic-webp.so<br>│   ├── mix.dex<br>│   └── mixz.dex<br>├── armeabi-v7a<br>│   ├── libBugly.so<br>│   ├── libgifimage.so<br>│   ├── libimagepipeline.so<br>│   ├── libjcore119.so<br>│   ├── libshella-2.9.1.2.so<br>│   └── libstatic-webp.so<br>├── </p>
<p>另外反编译出的AndroidManifest.xml内容：<br><application android:allowbackup="true" android:icon="@drawable/app_logo" android:label="@string/app_name" android:name="com.tencent.StubShell.TxAppEntry" android:supportsrtl="true" android:theme="@style/AppTheme"><br><meta-data android:name="TxAppEntry" android:value="com.huili.readingclub.MyApplication"><br>android:name=”com.tencent.StubShell.TxAppEntry”<br>其中有：<br>com.tencent.StubShell.TxAppEntry<br><meta-data android:name="TxAppEntry"><br>也是典型的腾讯乐固的内容。</meta-data></meta-data></application></p>
<p>360加固保的加固的目录结构<br>360加固后的apk经过dex2jar反编译后的目录结构是：<br>com.qihoo.util<br>com.qihoo360.replugin<br>com.stub<br>这种结构就说明是360加固保加固的。</p>
<hr>
<h1 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h1><p>hook startActivity概念:<br>一个活动界面启动另一个活动界面,需要打印相关的日志内容.</p>
<h2 id="hook-startActivity-的用法"><a href="#hook-startActivity-的用法" class="headerlink" title="hook startActivity 的用法"></a>hook startActivity 的用法</h2><p>(1) 定义两个活动界面,完成跳转<br>(2) 找到最终代理的地方来代理start activity<br>(3) 声明一个tag,以及代理类<br>(4) 定义ActivityThread里面的原始的Instrunmentation对象<br>(5) 定义原始方法里的真正启动的activity的方法<br>(6) 打印一些activity启动前后的日志信息,也可以修改相应参数信息<br>(7) 调用方法是否在底层,是否需要反射调用,以及设置可见.<br>(8) 进行代理在Application程序的入口点来写代码<br>(9) 在Application程序的入口点来写代码<br>(10) 获取当前的ActivityThread对象,然后进行调用<br>(11) 拿到在ActivityThread类里面的原始mInstrumentation对象<br>(12) 构建我们的代理对象<br>(13) 通过反射,换掉字段<br>(14) 做个标记,方便以后查看<br>(15) 运行完毕查看日志是否HOOk成功</p>
<h2 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h2><h3 id="Xposed的优缺点"><a href="#Xposed的优缺点" class="headerlink" title="Xposed的优缺点"></a>Xposed的优缺点</h3><p>优点：在编写Java层hook插件的时候非常好用，这一点完全优越于Frida和SubstrateCydia，因为他也是Android项目，可以直接编写Java代码调用各类api进行操作。而且可以安装到手机上直接使用。</p>
<p>缺点：配置安装环境繁琐，兼容性差，在Hook底层的时候就很无助了。</p>
<h3 id="插件开发步骤"><a href="#插件开发步骤" class="headerlink" title="插件开发步骤:"></a>插件开发步骤:</h3><ul>
<li>添加第三方jar包</li>
<li>配置插件入口类</li>
<li>编写hook代码</li>
</ul>
<h4 id="Xposed插件开发-https-q0o0p-top-2021-03-30-Xposed-hook"><a href="#Xposed插件开发-https-q0o0p-top-2021-03-30-Xposed-hook" class="headerlink" title="Xposed插件开发: https://q0o0p.top/2021/03/30/Xposed-hook/"></a>Xposed插件开发: <a target="_blank" rel="noopener" href="https://q0o0p.top/2021/03/30/Xposed-hook/">https://q0o0p.top/2021/03/30/Xposed-hook/</a></h4><p>注意:<br><code>当 Frida 使应用程序崩溃时，可以尝试Xposed。接下来，与丰富的 Frida脚本类似，可以轻松地使用 Xposed 附带的许多模块中的一个，例如前面讨论的绕过 SSL 检测的模块（JustTrustMe 和 sslunpining）。Xposed 还包括其他模块，比如Inspeckage，它允许进行更深入的应用程序测试。除此之外，还可以创建自己的模块来绕过 Android 应用程序常用的安全机制</code></p>
<h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><h3 id="Frida-介绍"><a href="#Frida-介绍" class="headerlink" title="Frida 介绍"></a>Frida 介绍</h3><p>frida 是一款基于 python 和 java 的 hook 框架，是一种动态插桩工具，可以插入代码到原生App的内存空间中，动态的监视和修改其行行为，可运行在Android、iOS、Linux和windows等多个平台。</p>
<p>插桩技术 是指将额外的代码注入程序中以收集运行时的信息，可分为两种：</p>
<ol>
<li>源代码插桩【Source Code Instrumentation(SCI)】：额外代码注入到程序源代码中。</li>
<li>二进制插桩【Binary Instrumentation】：额外代码注入到二进制可执行文件中，其又可分为两种：<br> ● 静态二进制插桩  【 Static Binary Instrumentation(SBI) 】：<pre><code>         在程序执行前插入额外的代码和数据，生成一个永久改变的可执行文件。
</code></pre>
 ● 动态二进制插桩  【 Dynamic Binary Instrumentation(DBI) 】：<pre><code>         在程序运行时实时地插入额外代码和数据，对可执行文件没有任何永久改变。
</code></pre>
</li>
</ol>
<h3 id="Frida-作用"><a href="#Frida-作用" class="headerlink" title="Frida 作用"></a>Frida 作用</h3><p>访问进程的内存<br>应用程序运行时覆盖功能<br>从导入的类调用函数<br>动态Hook跟踪、拦截函数等</p>
<p>客户端：PC（控制端）<br>客户端编写的 Python 代码，用于连接远程设备，提交要注入的 JS代码到服务端，接受服务端发来的消息。 </p>
<p>服务器：手机设备（被控制端）<br>服务端中需要用 JS 代码注入到目标进程，操作内存数据，给客户端发送消息。</p>
<h3 id="Frida的优缺点"><a href="#Frida的优缺点" class="headerlink" title="Frida的优缺点"></a>Frida的优缺点</h3><p>优点：在上面我们可以看到他的优点在于配置环境很简单，操作也很便捷，对于破解者开发阶段非常好用。支持Java层和Native层hook操作，在Native层hook如果是非基本类型的话操作有点麻烦。</p>
<p>缺点：因为他只适用于破解者在开发阶段，也就是他没法像Xposed用于实践生产中，比如我写一个微信外挂用Frida写肯定不行的，因为他无法在手机端运行。也就是破解者用的比较多。</p>
<h4 id="Frida实例-https-q0o0p-top-2021-03-24-cydia-hook"><a href="#Frida实例-https-q0o0p-top-2021-03-24-cydia-hook" class="headerlink" title="Frida实例: https://q0o0p.top/2021/03/24/cydia-hook/"></a>Frida实例: <a target="_blank" rel="noopener" href="https://q0o0p.top/2021/03/24/cydia-hook/">https://q0o0p.top/2021/03/24/cydia-hook/</a></h4><h3 id="SubstrateCydia的优缺点"><a href="#SubstrateCydia的优缺点" class="headerlink" title="SubstrateCydia的优缺点"></a>SubstrateCydia的优缺点</h3><p>优点：可以运行在手机端，和Xposed类似可以用于实践生产中。支持Java层和Native层的hook操作，但是Java层hook不怎么常用，用的比较多的是 Native 层 hook 操作，因为他也是Android工程可以引用系统api，操作更为方便。</p>
<p>缺点：和Xposed一样安装配置环境繁琐，兼容性差。</p>
<p>总结: <code>Java层Hook还是Xposed方便，写 Native 层 Hook 还是Cydia 了，而对于破解者开发那还是 Frida 最靠谱了。写外挂最难的也是最重要的不是写代码而是寻找 hook点，也就是逆向分析 app 找到那个地方，然后写 hook 代码实现插件功能。</code></p>
<hr>
<h2 id="Android安全机制"><a href="#Android安全机制" class="headerlink" title="Android安全机制"></a>Android安全机制</h2><p>系统中的文件的访问权限是通过<code>用户ID（UID）和用户组ID（GID）</code>来控制的。换句话说，就是Linux的安全机制是基于UID和GID来实现的。Android在Linux内核提供的基于UID和GID的安全机制的基础上，又实现了一套称为Permission的安全机制(三个基本角色：用户-&gt;进程-&gt;文件)<br>一个UID可以对应多个GID,用户属性划分为三组：Owner、Group和Other。</p>
<p>android安全机制覆盖到各个层面，求开放的同时也保护用户的数据，应用程序和设备的安全。主要安全模型如下： </p>
<h3 id="进程沙箱隔离机制"><a href="#进程沙箱隔离机制" class="headerlink" title="进程沙箱隔离机制"></a>进程沙箱隔离机制</h3><p>  进程沙箱隔离机制，使得Android应用程序在安装时被赋予独特的用户标识（UID），并永久保持。应用程序及其运行的Dalvik虚拟机运行在独立的Linux进程空间，与其它应用程序完全隔离。 </p>
<h3 id="应用程序签名机制"><a href="#应用程序签名机制" class="headerlink" title="应用程序签名机制"></a>应用程序签名机制</h3><p>有特例程序共享uid；<br>应用签名机制：规定APK文件必须被开发者进行数字签名，以便标识应用程序作者和在应用程序之间的信任关系。在安装应用程序APK时，系统安装程序首先检查APK是否被签名，有签名才能安装。当应用程序升级时，需要检查新版应用的数字签名与已安装的应用程序的签名是否相同，否则，会被当做一个新的应用程序。Android开发者有可能把安装包命名为相同的名字，通过不同的签名可以把他们区分开来，也保证签名不同的包不被替换，同时防止恶意软件替换安装的应用。</p>
<h3 id="权限声明机制"><a href="#权限声明机制" class="headerlink" title="权限声明机制"></a>权限声明机制</h3><p>权限声明机制：要想获得在对象上进行操作，就需要把权限和此对象的操作进行绑定。不同级别要求应用程序行使权限的认证方式也不一样，Normal级申请就可以使用，Dangerous级需要安装时由用户确认，Signature和Signatureorsystem级则必须是系统用户才可用。<br>访问控制机制：确保文件系统和永和数据不受非法访问。 </p>
<h3 id="访问控制机制"><a href="#访问控制机制" class="headerlink" title="访问控制机制"></a>访问控制机制</h3><h3 id="进程通信机制"><a href="#进程通信机制" class="headerlink" title="进程通信机制"></a>进程通信机制</h3><p>进程间通信机制binder，基于共享内存的Binder实现，提供轻量级的远程进程调用（RPC）。通过接口描述语言（AIDL）定义接口与交换数据的类型，确保进程间通信的数据不会溢出越界。 </p>
<h3 id="内存通信机制"><a href="#内存通信机制" class="headerlink" title="内存通信机制"></a>内存通信机制</h3><p>  内存管理机制，基于Linux的低内存管理机制，设计实现了独特的LMK，将进程重要性分级、分组，当内存不足时，自动清理级别进程所占用的内存空间。同时，引入的Ashmem内存机制，使得Android具备清理不再使用共享内存区域的能力。</p>
<p>正是因为Android采用多层架构，在保护信息安全的同时，也保证开放平台的灵活性。</p>
<h3 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h3><p>SE Android</p>
<p>看源码见<a target="_blank" rel="noopener" href="http://blog.csdn.net/luoshengyang/article/details/37613135">http://blog.csdn.net/luoshengyang/article/details/37613135</a><br>Android是一个基于Linux内核的系统，像传统的Linux系统一样，Android也有用户的概念。只不过这些用户不需要登录，也可以使用Android系统。Android系统将每一个安装在系统的APK都映射为一个不同的Linux用户。也就是每一个APK都有一个对应的UID和GID，这些UID和GID在APK安装的时候由系统安装服务PackageManagerService分配。Android沙箱隔离机制就是建立在Linux的UID和GID基础上。</p>
<p>这种基于Linux UID/GID的安全机制存在什么样的问题呢？</p>
<p>Linux将文件的权限划分为读、写和执行三种，分别用字母r、w和x表示。每一个文件有三组读、写和执行权限，分别针对文件的所有者、文件所有者所属的组以及除了所有者以及在所有者所属组的用户之外所有其它用户。这样，如果一个用户想要将一个自己创建的文件交给另外一个用户访问，那么只需要相应地设置一下这个文件的其它用户权限位就可以了。所以，在Linux系统中，文件的权限控制在所有者的手中。因此，这种权限控制方式就称为自主式的，正式的英文名称为Discretionary Access Control，简称为DAC。</p>
<p>在理想情况下，DAC机制是没有问题的。然而，一个用户可能会不小心将自己创建的文件的权限位错误地修改为允许其它用户访问。如果这个用户是一个特权用户，并且它错误操作的文件是一个敏感的文件，那么就会产生严重的安全问题。这种误操作的产生方式有三种：</p>
<p>用户执行了错误的命令<br>负责执行用户命令的程序有Bug<br>负责执行用户命令的程序受到攻击<br>后来，Linux内核采用了必要的访问控制机制：SE Linux（Security-Enhanced Linux），它采用了一种强制存取控制MAC（Mandatory Access Control）策略的实现方式，目的在于通过限制系统中的任何进程以及用户对资源的访问，保护内核安全。而SE Android（Security-Enhanced Android）是Android与SE Linux的结合，由美国NSA在2012年推出的Android操作系统安全强化套件，以支持在Android平台上使用SE Linux。</p>
<p>目前SE Android系统中的策略机制主要有三种：</p>
<p>安装时MAC（install-time MAC）<br>权限取消（permission revocation）<br>权限标签传播（tag propagation）<br>安装时MAC通过查找MAC策略配置来检查应用程序的权限。权限取消可以为已安装的应用取消权限，该机制在应用程序运行的权限检查时通过查找权限取消列表来取消应用的某些权限。权限标签传播是一种污点跟踪方式的应用，Android系统的权限作为抽象的标签映射到MAC策略配置文件中。</p>
<p>SE Android安全机制所要保护的对象是系统中的资源，这些资源分布在各个子系统中。实际上，系统中需要保护的资源非常多，除了文件之外，还有进程、socket和IPC等。SE Android是一个复杂的安全模型，本文就不进一步分析了。</p>
<p>如何解决这些安全问题</p>
<p>Android应用会遇到各种各样的安全性问题，如何从宏观上了解各种安全隐患，积极采取适当的防御措施便变得尤为重要。那么，Android应用面临哪些安全问题呢？</p>
<p>病毒<br>关键信息泄露<br>APP重打包<br>进程被劫持<br>数据在传输过程遭劫持<br>Webview漏洞<br>病毒不用多说了，都是一些恶意软件。关键信息泄露，可能有些开发者并不十分留意。虽然Java代码可以做混淆，但是Android的几大组件的创建方式是依赖注入的方式，因此不能被混淆。而且目前常用的一些反编译工具比如apktool等能够毫不费劲地还原Java里的明文信息，native里的库信息也可以通过objdump或IDA获取。因此一旦Java或native代码里存在明文敏感信息，基本上就是毫无安全而言的。重打包即通过反编译后重新加入恶意的代码逻辑，重新打包一个APK文件。进程被劫持一般通过进程注入或者调试进程的方式来hook进程，改变程序运行的逻辑和顺序，从而获取程序运行的内存信息。hook需要获取root权限或者跟被hook进程相同的权限。如果手机没被root，被劫持的可能性还是较小。数据在传输过程遭劫持，一般来说是由于数据明文传输或没使用HTTPS。Webview漏洞一般由于JS注入。</p>
<p>现实中，出现的问题可能比上面提及的还要多。总的来说，应该从以下几个方面来应对Android开发的常见安全问题：</p>
<p>应用权限控制。通过控制应用程序的权限防止恶意应用对系统造成破坏，采取的措施包括合理使用系统内置权限和应用程序自定义权限。<br>应用程序签名。采用数字签名为应用程序签名。<br>应用加固。应用加固包括病毒扫描、防注入、防调试、防篡改四个模块，目前行业内已经出现了很多的应用加固解决方案，如360应用加固、腾讯云应用加固、百度应用加固等等。<br>静态代码分析。通过静态代码分析工具lint监测安全隐患，对代码进行优化。<br>防火墙。必要时为Android设备安装防火墙，以防止远程网络攻击。<br>数据存储加密。采用加密的方式保护应用程序敏感数据，如利用SQLCipher加密SQLite数据库。<br>应用程序组件开发的安全要点。Activity, Service, Content Provider, Broadcast Receiver等组件在代码层面应采取的安全措施。它们每一个都可以通过隐式的Intent方式打开，所以这些组件只要不是对外公开的必须在AndroidManifest里面注明exported为false，禁止其它程序访问我们的组件。对于要和外部交互的组件，应当添加访问权限的控制，还需要要对传递的数据进行安全的校验。</p>
<p>当然，还有Android NDK(Native Development Kit)，使得应用程序可以不依赖Dalvik虚拟机进行开发。Android运行时核心库提供android.os, android.net, android.media等核心API，而Dalvik虚拟机依赖Linux内核，实现进程隔离与线程调度管理、安全与异常管理、垃圾回收等功能，并被改进以适应低内存、低处理器速度的移动设备环境。</p>
<p>再往上就是应用程序框架层了。一系列的Android应用程序所需的类库，使得开发人员可以快速地进行程序开发，也可以通过继承实现个性化的扩展。如Activity Manager负责主线程ActivityThread的创建、Activity生命周期的维护，并为窗口提供交互的接口。</p>
<p>应用层就是与用户直接交互的应用程序，如SMS短信、图片浏览器、地图以及开发人员所开发的应用程序。</p>
<hr>
<h2 id="Android系统架构如下："><a href="#Android系统架构如下：" class="headerlink" title="Android系统架构如下："></a>Android系统架构如下：</h2><p>android采用自下而上的分层架构，linux内核层，硬件抽象层，运行时和c语言库，程序框架层和应用层。<br>Android以linux内核为基础实现硬件设备驱动，进程和内存管理，网络协议栈、电源管理等核心系统功能。android基于移动设备在linux的基础上补充了内存管理，匿名共享内存和进程间通信binder。 </p>
<p>HAL(Hardware Abstraction Layer)规定了一套应用层对硬件层的读写和配置的统一接口，本质上是将硬件的驱动分为用户空间和内核空间，其中内核驱动程序运行在内核空间，HAL运行在用户空间。上图中的Stub，以so库的形式存在，可以理解为proxy。上层通过调用标识获得HAL的相关Stub，进而取得相应操作。</p>
<hr>
<h2 id="经典漏洞"><a href="#经典漏洞" class="headerlink" title="经典漏洞"></a>经典漏洞</h2><h3 id="Master-Key漏洞"><a href="#Master-Key漏洞" class="headerlink" title="Master Key漏洞"></a>Master Key漏洞</h3><p>官方的文章：<a target="_blank" rel="noopener" href="http://bluebox.com/corporate-blog/bluebox-uncovers-android-master-key/">http://bluebox.com/corporate-blog/bluebox-uncovers-android-master-key/</a></p>
<ol>
<li>找到一个具有系统签名的APP，并且这个APP通过android:sharedUserId属性申请了android.uid.system这个UID。</li>
<li>通过Master Key向这个APP注入恶意代码。</li>
<li>注入到这个APP的恶意代码在运行时就获得了system用户身份。</li>
<li>修改/data/local.prop文件，将属性ro.kernel.qemu的值设置为1。</li>
<li>重启手机，由于ro.kernel.qemu的值等于1，这时候手机里面的adb进程不会被setuid剥夺掉root权限。</li>
<li>通过具有root权限的adb进程就可以向系统注入我们熟悉的su和superuser.apk，于是整个root过程完成。</li>
</ol>
<p><code>注意，第1步之所以要找一个具有系统签名的APP，是因为通过android:sharedUserId属性申请android.uid.system这个UID需要有系统签名，也就是说不是谁可以申请system这个UID的。另外，/data/local.prop文件的Owner是system，因此，只有获得了system这个UID的进程，才可以对它进行修改。</code></p>
<p>  再说说Signature与Permission的关系。有些Permission，例如INSTALL_PACKAGE，不是谁都可以申请的，必须要具有系统签名才可以，这样就可以控制Suppementary GID的分配，从而控制应用程序进程的权限。具有哪些Permission是具有系统签名才可以申请的，可以参考官方文档：<a target="_blank" rel="noopener" href="http://developer.android.com/reference/android/Manifest.html%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%93%AA%E4%BA%9B%E6%A0%87%E8%AE%B0%E4%B8%BA%E2%80%9CNot">http://developer.android.com/reference/android/Manifest.html，就是哪些标记为“Not</a> for use by third-party applications”的Permission。</p>
<p>了解了Android的Permission机制之后，就可以知道：</p>
<pre><code>     1. Android的APK就相当于是Linux的UID。
     2. Android的Permission就相当于是Linux的GID。
     3. Android的Signature就是用来控制APK的UID和GID分配的。
</code></pre>
<hr>
<h2 id="常用调试工具"><a href="#常用调试工具" class="headerlink" title="常用调试工具"></a>常用调试工具</h2><p>Smali、Dedexer、Dexdump、Apktool、Dex2jar、jd-gui。<br>ida动态调式和代码跟踪<br>IDA工具分析的ARM汇编，IDA打开SO文件看到的就是ARM汇编指令。</p>
<h3 id="JADX"><a href="#JADX" class="headerlink" title="JADX"></a>JADX</h3><p>介绍一个反编译利器 JADX ，它可以直接将 Apk 反编译成 Java 代码进行查看，毕竟 smali 代码不是那么人性化。<br>直接就可以看到对应的 Java 代码，理清逻辑之后再去阅读 smali 代码进行修改，事半功倍。支持反编译 Java 代码的工具还有很多，例如基于 Python 实现的 Androgurad 等等。</p>
<h3 id="DexExtractor"><a href="#DexExtractor" class="headerlink" title="DexExtractor"></a>DexExtractor</h3><p>功能：<br>用于破解邦邦加密的安卓dex文件提取器<br>github主页<br>lambdalang/DexExtractor<br>使用说明<br>4.4的虚拟机 编译好了libdvm。<br>代码github上，脱梆梆的壳，别的没测试<br>把dexdump出来，然后base64解码下，然后odex2dex，没了<br>system.img 有空上传<br>作者编译好的镜像文件system.img的下载地址<br>system-arm_md5_6395c2f1451dbbed027d7293ab39a6e7.img.tar.gz<br>启动模拟器加上sdcard<br>注意<br>apk没有写权限的反编译了加上write就好了。<br>支持<br>梆梆加固<br>爱加密（新版本没事）<br>其他，暂时没测试</p>
<h3 id="InDroid"><a href="#InDroid" class="headerlink" title="InDroid"></a>InDroid</h3><ul>
<li>romangol/InDroid: Dalvik vm Instrumentation OS</li>
<li>作者：GoSSIP小组</li>
<li>功能：基于Dalvik VM的插桩分析框架</li>
<li>原理：<br>直接修改AOSP上的Dalvik VM解释器，在解释器解释执行Dalvik字节码时，插入监控的代码，这样就可以获取到所有程序运行于Dalvik上的动态信息，如执行的指令、调用的方法信息、参数返回值、各种Java对象的数据等等。InDroid只需要修改AOSP的dalvik vm部分代码，编译之后，可直接将编译生成的新libdvm.so刷入任何AOSP支持的真机设备上</li>
</ul>
<h3 id="drizzleDumper"><a href="#drizzleDumper" class="headerlink" title="drizzleDumper"></a>drizzleDumper</h3><p>听别人提到过，自己没用过。</p>
<ul>
<li>功能：一款基于内存搜索的Android脱壳工具<br>可以从运行中的安卓app中，利用ptrace机制，导出dex文件<br>github主页<br>DrizzleRisk/drizzleDumper: drizzleDumper是一款基于内存搜索的Android脱壳工具<br>机制和原理<br>root设备之后，通过ptrace附加需要脱壳的apk进程，然后在脱壳的apk进程的内存中进行dex文件的特征搜索，当搜索到dex文件时，进行dex文件的内存dump<br>使用步骤<br>将 \armeabi 下的drizzleDumper push进手机<br>进入shell，赋给可执行权限<br>运行drizzleDumper [包名] [等待时间,默认为0]<br>运行需要脱壳程序<br>使用举例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&gt;adb push F:\drizzleDumper /data/<span class="built_in">local</span>/tmp</span><br><span class="line">$&gt;chmod 755 drizzleDumper</span><br><span class="line">$&gt;./drizzleDumper xyz.sysorem.crackme</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h3><ul>
<li><p>IDA 动态调试环境搭建<br>将F:\AndroidTools\IDA_Pro_v7.5_Portable\dbgsrv路径下的android_server<br>push到模拟器上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push F:\AndroidTools\IDA_Pro_v7.5_Portable\dbgsrv\android_server /data/<span class="built_in">local</span>/tmp</span><br></pre></td></tr></table></figure>
<p>模拟器终端运行android_server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su </span><br><span class="line"><span class="built_in">cd</span> /data/<span class="built_in">local</span>/tmp</span><br><span class="line">chmod 777 android_server</span><br><span class="line">./android_server //端口被占用使用./android_server -p31928 修改端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/19/Android-Reverse/3.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> //端口转发,必须与android_server运行的端口一致</span><br><span class="line">adb forward tcp:23946 tcp:23946</span><br></pre></td></tr></table></figure>
<p>打开IDA -&gt; Debugger -&gt; Attach -&gt; Remote ARMLinux/Android debugger</p>
</li>
<li><blockquote>
<p>hostname:127.0.0.1 </p>
</blockquote>
</li>
<li><blockquote>
<p>端口填写以上端口 -&gt; 点击ok </p>
</blockquote>
</li>
<li><blockquote>
<p>呈现所有手机上运行中的程序的一个线程(搜索要调试的应用,当然首先模拟器要打开此app)<br>选择以后点击ok </p>
</blockquote>
</li>
<li><blockquote>
<p>debugger </p>
</blockquote>
</li>
<li><blockquote>
<p>debugger option </p>
</blockquote>
</li>
<li><blockquote>
<p>勾选 Suspend on process,<br>Suspend on thread,Suspend on library<br><img src="/2021/02/19/Android-Reverse/4.png"></p>
</blockquote>
</li>
<li><p>IDA 窗口介绍<br>空格 : 视图切换<br>IDA-view-PC : 反汇编窗口<br>Hex-view : 十六进制编辑窗口<br>Outout windows : 输出窗口<br>general register : 寄存器窗口<br>Stack view : 栈视图<br>View -&gt; Open subviews -&gt; String : 字符串编辑窗口 (Shift+F12)<br>可以看到此程序所有常量字符串列表(分析方向之一)<br>Search -&gt;Search : 字符串查找窗口<br>Jump -&gt; Jump Address : 地址跳转<br>File -&gt; Script file : 脚本执行窗口(选择执行的脚本)<br>右键点击函数名 -&gt; List cross refereaces to (Ctrl+x) : 交叉引用</p>
</li>
<li><p>IDA 快捷键<br>F2: 下断点<br>F7: 单步步入(点击可以继续往下走)<br>F8: 单步步过(不执行函数直接过去)<br>F4: 运行到光标所在(程序运行到光标所在之处)<br>G: 可以直接跳到一个地址<br>U: 把一个数据解析成未定义的数据(Udefine)<br>C: 将数据解析成汇编指令<br>P: 将汇编指令识别成函数<br>Ctrl+F: 搜素指令<br>F5: 将汇编识别为伪代码<br>Alt+G: 判断当前的系统的指令是Thumb还是ARM<br>Ctrl+S: 查看系统中所有的模块<br>X: 交叉引用(可以看到所有对此字符串或函数的一个引用)</p>
</li>
<li><p>修改寄存器的值<br>(1) 选中寄存器,右键选择<code>Modify value</code> 可以改为任意值<br>(2) 选中寄存器,直接<code>Zero value</code>选项,置零 </p>
</li>
<li><p>篡改内存数据<br>例如 IDA View-PC<br>ADD R2,PC,R2<br>Hex View<br>右键 -&gt; Synchrogazer with -&gt; R2 -&gt; F2修改十六进制的值在次使用F2提交</p>
</li>
<li><p>NOP函数或代码<br>可用于过反调试,将该函数值置为零<br>(1) 选中函数或代码,来到十六进制窗口<br>(2) 鼠标右键,选择Synchrogazer with 同步寄存器<br>(3) 选中目标,右键 -&gt; Edit(F2)修改<br>(4) 继续右键 -&gt; Edit(F2)提交<br>程序执行到此处会编译执行下一条,紧接着读取下一条,修改需要隔三条进行修改<br>(三级流水线)</p>
</li>
<li><p>改变程序执行流程<br>改变引起跳转指令的执行流程<br>如: BLX R3<br>  CMP R0 ,#0  :BLX执行完毕会把返回值放到R0寄存器,CMP把R0和0进行比较<br>  BNE loc_75566433   :不等于则跳转<br>BNE<br>改变BNE指令执行条件,从而无法跳转目的地址,进而执行无法跳转目的地址</p>
</li>
<li><p>IDA 检测(关键文件检测)<br>data/local/tmp 目录下存在android_server 所运行的程序kill<br>IDA静态分析,打开后看到 sub_588: main函数(双击) -&gt; 看到字符串(tab一下)</p>
</li>
<li><blockquote>
<p>C语言查看代码逻辑 -&gt; 字符串右键, 交叉引用</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="调试与反调试"><a href="#调试与反调试" class="headerlink" title="调试与反调试"></a>调试与反调试</h2><h3 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h3><h3 id="运行调试端口检测-kill程序"><a href="#运行调试端口检测-kill程序" class="headerlink" title="运行调试端口检测,kill程序"></a>运行调试端口检测,kill程序</h3><p>端口检测方法C语言:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE* pfile=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">0x1000</span>])= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//执行命令 </span></span><br><span class="line">  <span class="keyword">char</span>* strCatTcp = <span class="string">&quot;cat /proc/net/tcp |grep :5D8A&quot;</span>; <span class="comment">//android_server默认使用端口号(十六进制)</span></span><br><span class="line">  <span class="keyword">char</span>* strNetstat=<span class="string">&quot;netstat |grep :23946&quot;</span>;</span><br><span class="line">  pfile = popen(strCatTcp,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> pid=getpid();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> =pfile)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;打开命令失败!\n&quot;</span>, );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(fgets(buf,<span class="keyword">sizeof</span>(buf),pfile)) &#123;</span><br><span class="line">        <span class="comment">//执行到这里判断调试状态</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;执行cat /proc/net/tcp |grep :5D8A的结果是: \n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf );</span><br><span class="line">      <span class="keyword">int</span> ret =kill(pid,SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">  pclose(pfile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x =<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> y= <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  x=x^y;</span><br><span class="line">  y=x^y;</span><br><span class="line">  <span class="keyword">int</span> X=x^y;</span><br><span class="line">  <span class="keyword">int</span> Y=x^y; </span><br><span class="line">  Y=Y&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> X0=x^y;</span><br><span class="line">  <span class="keyword">int</span> Y0=x&amp;y;</span><br><span class="line">  Y0=Y0 &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (Y0==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    key=x0+<span class="number">4543</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> encrypt = num ^ key;</span><br><span class="line">  <span class="keyword">int</span> decrypt = encrypt ^ key;</span><br><span class="line">  check()</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;加密前\n&quot;</span>,num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;加密后\n&quot;</span>,encrypt);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;解密后\n&quot;</span>,decrypt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>过滤端口检测的方法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android_server -p指定端口号</span><br></pre></td></tr></table></figure>
<h3 id="进程名称检测"><a href="#进程名称检测" class="headerlink" title="进程名称检测"></a>进程名称检测</h3><p>进程名称检测C语言:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">filename</span><span class="params">(bufsize)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">line</span><span class="params">(bufsize)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">name</span><span class="params">(bufsize)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">nameline</span><span class="params">(bufsize)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> pid = getpid();</span><br><span class="line">  <span class="comment">//先读取Tracepid值</span></span><br><span class="line">  <span class="built_in">sprintf</span>(filename,<span class="string">&quot;/proc/%d/status&quot;</span>,pid);</span><br><span class="line">  FILE *fd=fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,bufsize,fd)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(line,<span class="string">&quot;Tracepid&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">int</span> statue = atoi(&amp;line[<span class="number">10</span>]);</span><br><span class="line">          <span class="keyword">if</span> (statue !=<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            sprint(name,<span class="string">&quot;/proc/%d/cmdline&quot;</span>,statue);</span><br><span class="line">            FILE *fdname =fopen(name,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (fdname!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">while</span>(fgets(nameline,bufsize,fdname)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">strstr</span>(nameline,<span class="string">&quot;android_server&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">int</span> ret=kill(pid,SIGKILL);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fclose(fdname),</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDA调试可执行文件<br>IDA -&gt; Debugger -&gt; Run -&gt; Remote ARMLinux…<br>-&gt; 以下信息必填:<br>  Application: 文件路径+文件名<br>  Directory: 程序所在路径<br>  Hostname: 127.0.0.1  , Port: 运行android_server转发端口号<br>-&gt; ok之后程序处于挂起状态<br>-&gt; (android shell端执行)ps | grep 该程序名称(查看端口号,第一个数字字符串)<br>-&gt; cat /proc/端口号/status (此进程详细信息)</p>
<p>过掉反调试<br>(1) 动态调试把tracepid函数的返回值改为零,或者直接nop掉该函数<br>(2) 刷机,修改系统内核,永久绕过反调试</p>
<h3 id="轮循检测"><a href="#轮循检测" class="headerlink" title="轮循检测"></a>轮循检测</h3><p>反调试方法之一,保护程序代码会一直监视进程的tracepid是否发生变化,<br>不断轮循检测Tracepid的值,假如为0 -&gt; 没有被调试<br>假如不为0,说明当前进程正在被调试.</p>
<h3 id="self-debugger反调试原理"><a href="#self-debugger反调试原理" class="headerlink" title="self-debugger反调试原理"></a>self-debugger反调试原理</h3><ul>
<li><p>原理<br>(1) 当前进程就是父进程,也就是即将被调试的进程<br>(2) 通过父进程fork一个子进程<br>(3) 该子进程实现调试器功能<br>(4) 作为调试器的子进程附加父进程而禁止其他调试器来调试父进程</p>
</li>
<li><p>过滤self-debugger反调试<br>附加它的子进程<br>如果添加子进程后,直接用IDA附加调试,调试不上(可能有IDA反调试),双开IDA,找到创建进程的位置,<br>直接在Fork函数下断即可.</p>
</li>
</ul>
<h3 id="java层反调试"><a href="#java层反调试" class="headerlink" title="java层反调试"></a>java层反调试</h3><p><code>java层动态调试需要满足:</code><br><code>(1) 在AndroidMainfest.xml文件中,application标签下,Android:debuggable=true</code><br><code>(2) 系统默认调试,在build.prop(boot.img) , ro.debuggabel=1</code></p>
<ul>
<li><p>百度加固演示<br>将样本拖入jdax-gui进行反编译(会调用Debug.isDebuggerConnected函数检测程序被调试反调)</p>
</li>
<li><p>绕过java层反调试方法<br>AndroidKiller中搜索isDebugger… </p>
</li>
<li><blockquote>
<p>smail文件中找到判断语句(如: if nez 改为-&gt; if eqz不相等跳转改为相等跳转)</p>
</blockquote>
</li>
<li><blockquote>
<p>保存 -&gt; 打包 -&gt; 签名</p>
</blockquote>
</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>(1) 接口类的创建<br>(2) 定义方法,实现接口类的类<br>(3) 实现接口类的方法<br>(4) 创建代理并实现类<br>(5) 实现接口后声明一个对象后进行实例,得到对象<br>(6) 在代理类里面定义两个方法分别是代理前,后<br>(7) 调用代理类里的方法,做出相应的修改(参数,返回值)<br>(8) MainActivity里实例化代理类<br>(9) 运行打印一下log日志信息</p>
<hr>
<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><h3 id="混淆的概念"><a href="#混淆的概念" class="headerlink" title="混淆的概念"></a>混淆的概念</h3><p>通过一些工具对函数名,变量名,类名,字段名进行批量的重命名<br>但整体逻辑是清晰的</p>
<h3 id="ProGuard"><a href="#ProGuard" class="headerlink" title="ProGuard"></a>ProGuard</h3><p>检测和移除未使用的类,字段名,方法和属性<br>优化字节码,移除未使用到的代码指令</p>
<h2 id="资源混淆"><a href="#资源混淆" class="headerlink" title="资源混淆"></a>资源混淆</h2><p>MT管理器绕过资源文件的触发(捕鱼达人)<br>MT管理器 -&gt; data/app/程序包名<br>-&gt; 点击.apk查看<br>-&gt; 点击.dex文件<br>-&gt; dex编辑器++<br>-&gt;反编译完成(里面的方法修改后会出现星号)<br>-&gt; 修改完成把保存并退出(绿色表示修改成功)<br>-&gt; 双击覆盖安装</p>
<p>MT管理器原理: 基于压缩包进行反编译,可以反编译单独的dex</p>
<h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>签名修改后安装出现闪退(存在签名验证)<br>(1) 阅读签名验证源码<br>打开文件 -&gt; 开始分析java层 -&gt; 重新打包,回编译<br>获取包管理,从而获取签名信息<br>(2) 分析以及过掉签名验证<br>安装程序包 -&gt; 对程序包重新签名 -&gt; 安装签名过后的程序 -&gt; 开始分析<br>打开就提示错误 -&gt; 逻辑检查 OnCreate -&gt;native(so层检测)<br>-&gt; IDA打开lib目录下的so文件<br>-&gt; 搜索JNI_onload(没有JNI_onload,不是采用动态组成)<br>-&gt; 在搜索java_(有结果,双击分析)<br>-&gt; 看到getSignHashCode(点击)<br>-&gt; 看到getPackageManager , getPackageInfo , getPackageName(签名三兄弟)<br>-&gt; 还有signatures,hashcode(一块一块的函数的调用)<br>-&gt; F5看伪代码<br>-&gt; 上一层只传一个R0(env),第二个参数在java层代码,没有被static修饰,说明obj<br>-&gt; 右键Hide-casts 隐藏类型</p>
<h3 id="JNI-OnLoad简介"><a href="#JNI-OnLoad简介" class="headerlink" title="JNI_OnLoad简介"></a>JNI_OnLoad简介</h3><p>Java JNI有两种方法，一种是通过javah,获取一组带签名函数，然后实现这些函数。<br>这种方法很常用，也是官方推荐的方法。<br>还有一种就是JNI_OnLoad方法。<br>​<br>当Android的VM(Virtual Machine)执行到C组件(即<em>so档)里的System.loadLibrary()函数时，<br>首先会去执行C组件里的JNI_OnLoad()函数。<br>它的用途有二：<br>. 告诉VM此C组件使用那一个JNI版本。<br>  如果你的</em>.so档没有提供JNI_OnLoad()函数，VM会默认该*.so档是使用最老的JNI 1.1版本。<br>  由于新版的JNI做了许多扩充，如果需要使用JNI的新版功能，<br>  例如JNI 1.4的java.nio.ByteBuffer,就必须藉由JNI_OnLoad()函数来告知VM。</p>
<hr>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>打包，编译和破解的流程是什么样的？ </p>
<ol>
<li><p>Android的生命周期<br>onCreate - onStart - onResume - onPause - onStop - onDestory - onRestart</p>
</li>
<li><p>Android的入口函数？<br>继承了application类中的attachContext,onCreate</p>
</li>
<li><p>xposed框架的原理及常用函数？<br>替换system/bin/app_process文件，app_process就是zygote进程文件，所以xposed通过替换zygote进程实现了控制手机上所有app进程<br>常用函数<br>（1）findAndHookMethod<br>（2）findAndHookConstructor hook构造函数<br>(3)findClass：使用指定的类加载器查找类<br>（4）findField : 在类中查找自动并将其设置为可访问<br>(5)CallMethod 调用给定对象的实例或静态方法<br>(6)newInstance 创建给定类的新实例</p>
</li>
<li><p>hook和注入有哪些？<br>hook：反射（在程序运行的时候，对任意一个类，都可以获取其方法及变量）<br>java的动态代理（smali注入）</p>
</li>
<li><p>反调试<br>Tracerpid不等于0<br>Ptrace自身.<br>IsDebuggerConnect。</p>
</li>
<li><p>加壳<br>加壳的另一种常用的方式是在二进制的程序中植入一段代码，在运行的时候优先取得程序的控制权，做一些额外的工作。大多数病毒就是基于此原理。加壳的程序经常想尽办法阻止外部程序或软件对加壳程序的反汇编分析或者动态分析，以达到它不可告人的目的。这种技术也常用来保护软件版权，防止被软件破解。 </p>
</li>
<li><p>了解反破解的技术<br>我目前掌握的技术有：<br>1，反模拟器<br>2，反静态代码分析器如：反jeb<br>应该也是有很多反ida的，也就是加壳。</p>
</li>
<li><p>安卓程序的加解密和数据传输分析、拆解、逆向等工作;<br>加解密：这就很多了，一般都是遇到后再折腾解密，而且解密代码和秘钥一般都在代码里面。 </p>
</li>
<li><p>Andorid本地提权获得root权限，一般真机是用recovery刷机包，但是病毒提权是怎么样的<br>目前掌握的一种提权的是像输入命令行一样输入su并且用pm提权<br>还有一种是修改init.rc文件</p>
</li>
<li><p>Android逆向能做什么？</p>
</li>
</ol>
<p> 破解APP，实现各种功能，二次打包。<br> 分析算法，一些数据处理算法，自己开发不会写，就可以用逆向借鉴一些功能和算法。<br> APP协议，实现数据的抓取，得到数据后定点投放广告和协议操作等。协议本身APP本身存在的漏洞和BUG，可以实现模拟数据发送，实现篡改（这个属于是BUG）。单纯安卓逆向只能分析APP端和服务器发送给你的本身的数据，服务器本身不返回的数据APP逆向是没办法的。WEB安全则可以提权，获得主动权，威胁更大。<br> APP客户端安全测试，扫描漏洞，可以解决上述问题。<br> APP加固，用于保护APP的安全。<br> APP病毒木马分析，这样才能写安全软件，保护手机系统的安全。反方向就是逃避检测规则，做到免杀。<br> ARM汇编指令集就是转换为最底层的机器语言，由CPU去执行的。<br> 物联网也是基于ARM汇编的底层，IOT安全也是未来的趋势。</p>
<ol start="11">
<li><p>简单介绍一下Java层逆向？<br>JAVA开发（JAVA层） 主要用于协议部分，算法这一块需要用到，有部分还有C写的，只要接触到SO文件分析的都有C的影子。<br>系统源码分析部分，APP的启动分析。<br>APP一、二代加固。一代加固主要是隐藏JAVA代码（DEX文件）。二代加固主要是隐藏DEX文件里面的关键核心部分。C在加固部分应用得最多。<br>学习C的目的是让你更理解汇编指令。<br>SO文件是用C和C++写的代码编译后的文件。APP程序运行的时候安卓系统有接口调用SO文件。<br>NDK主要的功能就是让JAVA能够去访问底层的C++代码，是C代码和JAVA代码的一个调用。</p>
</li>
<li><p>能否简单介绍一下smali代码？<br>Dex文件反编译后的文件，得到Smali代码，可以用于分析代码、分析逻辑，知道别人软件的这个功能是怎么实现的。<br>Dex文件还可以反编译为JAR包，JAR包就是JAVA代码。</p>
</li>
<li><p>为什么用Smali代码不用JAVA代码分析<br>就是因为JAVA代码混淆比较严重，主要混淆是“函数名”，“类名”，“变量”，“包名”。<br>混淆机制是安卓程序员开发的，用于保护代码安全。混淆是属于内部保护机制，内部保护是通过内部去处理的，程序是按照正常流程去运行的，不存在加固后的解壳环节。内部保护安全性还是比较弱，没有外部保护的安全高。<br>Smali代码和JAVA代码的关联就是Smali代码不易懂，开发比较负责，JAVA代码开发效率高。Smali代码属于中间层处理系统，底层是汇编。Dalvik指令集取到一个转换的工作，转换为ARM汇编语言。</p>
</li>
<li><p>常见的hook框架，你怎么理解呢？<br>Xposed框架和frida都属于HOOK框架。<br>frida协议分析方向比较多，主要用于测试。JAVA层和SO层的HOOK，比较复杂，要会逆向分析，使用难度高。</p>
</li>
</ol>
<p>15.SE Android安全机制所要保护的对象是什么？<br>SE Android安全机制所要保护的对象是系统中的资源，这些资源分布在各个子系统中.<br>实际上，系统中需要保护的资源非常多，除了文件之外，还有进程、socket和IPC等。</p>
<hr>
<h2 id="逆向思维"><a href="#逆向思维" class="headerlink" title="逆向思维"></a>逆向思维</h2><p>获取注册码<br>一般有三种方式，打 log，动态调试 smali，自己写注册机。<br>打 log 日志<br>其实在逆向过程中，注入 log 代码是很常见的操作。适当的打 log，可以很好的帮助我们理解代码执行流程。在这里例子中，最终会拿我们输入的注册码和正确的注册码进行比较，在比较的时候我们就可以通过打 log 把正确的注册码打印出来，这样我们就可以直接输入注册码进行注册了。</p>
<p>打 log 的 smali 代码是固定的，一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const-string vX, &quot;TAG&quot;invoke-static &#123;vX,vX&#125;, Landroid/util/Log;-&gt;e(Ljava/lang/String;Ljava/lang/String;)I</span><br></pre></td></tr></table></figure>

<p>vX 都是指寄存器。把这两行代码加到注册码的检验操作之前就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.line 63.local v6, &quot;userSN&quot;:Ljava/lang/String;  # userSN = sb.toString()const-string v8, &quot;TAG&quot;invoke-static &#123;v8,v6&#125;, Landroid/util/Log;-&gt;e(Ljava/lang/String;Ljava/lang/String;)I# userSN.equalsIgnoreCase(sn)invoke-virtual &#123;v6, p2&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z</span><br><span class="line"></span><br><span class="line">const-string v8, &quot;TAG&quot;</span><br><span class="line">invoke-static &#123;v8,v6&#125;, Landroid/util/Log;-&gt;e(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line"></span><br><span class="line"># userSN.equalsIgnoreCase(sn)</span><br><span class="line">invoke-virtual &#123;v6, p2&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z</span><br></pre></td></tr></table></figure>
<p>再次重新打包运行，输入用户名和注册码，会得到日志</p>
<p>动态调试 smali<br>动态调试 smali 来的更加直截了当。不管是你自己写程序，还是做逆向，debug 永远都是快速理清逻辑的好方法。smali 也是可以进行动态调试的，依赖于 Smalidea 插件，你可以在 Android Studio 的 Plugin 中进行安装，也可以下载下来本地安装。</p>
<p>第一步，我们要保证我们的应用处于 debug 版本，在 AndroidManifest.xml 中加上 android:debuggable=”true” 即可，重打包再安装到手机上。</p>
<p>第二步，将之前反编译得到的 smali 文件夹导入 Android Studio 或者 IDEA，并配置远程调试环境。选择 Run -&gt; Edit Configurations，点击左上角 + 号，选择 Remote，弹出配置窗口，如下图所示：<br><img src="/2021/02/19/Android-Reverse/2.png"></p>
<p>注意记住自己填写的端口号，端口号不是固定的，只要未被占用即可。配置完成后，记得在合适的地方打上断点，我这里就在 checkSN() 方法内打上断点。</p>
<p>第三步，命令行启动进程调试等待模式。首先执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -D -n com.droider.crackme0201/.MainActivity</span><br></pre></td></tr></table></figure>
<p>然后建立端口转发，输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:8700 jdwp:pid</span><br></pre></td></tr></table></figure>
<p>用你自己的应用的 pid 替换进去。关于 pid 的获取，可以通过 ps 和 grep 组合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps | grep com.droider.crackme0201u0_a364   30110 537   2166480 30204 futex_wait 0000000000 S com.droider.crackme0201</span><br></pre></td></tr></table></figure>
<p>这里的 pid 就是 30010 。</p>
<p>最后在 Android Studio 或 IDEA 中启动 debug 。 点击 Run -&gt; Debug，应用就进入调试模式了。之后的操作就和开发中的 debug 模式一模一样了。我们可以在运行中看到寄存器中的值，运行逻辑一览无遗。运行至注册码校验处的断点，截图如下：</p>
<p>640?wx_fmt=png<br>userName 是用户名，sn 是输入的注册码，userSN 是正确的注册码。</p>
<hr>
<h1 id="adb的相关使用"><a href="#adb的相关使用" class="headerlink" title="adb的相关使用"></a>adb的相关使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity top //显示当前页的activity.</span><br><span class="line">adb shell dumpsys package 包名 //获取包信息</span><br><span class="line">adb shell dumpsys meminfo 包名 //获取当前应用程序的内存数据</span><br><span class="line">adb shell dumpsys dbinfo packagename //获取数据库文件</span><br><span class="line">adb shell  pm list packages //列出当前所有已安装的程序包名</span><br><span class="line">adb shell pm path packagename //获取指定程序所在的路径</span><br><span class="line">adb shell dumpsys window | findstr mCurrentFocus //当前应用包名</span><br><span class="line"></span><br><span class="line">adb pull //设备中文件放到本地</span><br><span class="line">adb push //本地文件放到设备中</span><br><span class="line">adb shell screencap -p 截图文件路径/.png //截图</span><br><span class="line">adb shell sceenrecord 视频保存路径/.mp4  //视屏录制</span><br><span class="line">adb shell input text <span class="string">&#x27;q0o0p&#x27;</span>//可以模拟物理按键,虚拟键盘,滑动,滚动</span><br><span class="line">adb forward [(远程端)协议:端口号] [(客户端)协议:端口号] //用于ida调试</span><br><span class="line">adb jdwp//查看设备中可以被调试的应用的进程号</span><br><span class="line">adb logcat -s tag //查看当前日志信息</span><br><span class="line">adb logcat|findstr pname/pid/keyword //adb logcat|findstr com.q0o0p</span><br><span class="line"></span><br><span class="line">//过滤 Logcat 输出，以特定的应用程序为目标：</span><br><span class="line">$ adb logcat | grep <span class="string">&quot;<span class="subst">$(adb shell ps | grep &lt;package-name&gt; | awk &#x27;&#123;print $2&#125;&#x27;)</span>&quot;</span></span><br><span class="line">//备份过程完成后，ab 文件将在您的工作目录中。运行以下命令将 ab 文件转换为 tar 文件。</span><br><span class="line">$ dd <span class="keyword">if</span>=mybackup.ab bs=24 skip=1|openssl zlib -d &gt; mybackup.tar</span><br><span class="line">//如果您得到错误 openssl:Error: <span class="string">&#x27;zlib&#x27;</span> is an invalid <span class="built_in">command</span>。您可以尝试使用 Python代替。</span><br><span class="line">$ dd <span class="keyword">if</span>=backup.ab bs=1 skip=24 | python -c <span class="string">&quot;import </span></span><br><span class="line"><span class="string">zlib,sys;sys.stdout.write(zlib.decompress(sys.stdin.read()))&quot;</span> &gt; backup.tar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run-as [package name]//非root设备中查看指定debug模式包名应用沙盒数据</span><br><span class="line">ps |grep //查看设备的进程信息,ps |grep ocm.q0o0p</span><br><span class="line">ps -t [pid] //查看pid对应的线程信息,ps -t 11798</span><br><span class="line">ps clear [package name] //清空一个应用的数据</span><br><span class="line">am start -n [包(package)名]/[包名].[活动(activity) 名称]//启动一个应用</span><br><span class="line">am startservice</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="除去广告"><a href="#除去广告" class="headerlink" title="除去广告"></a>除去广告</h2><p>一、删除广告网络权限（去除广告）,在AndroidManifest.xml中删除如下权限信息：<br>与网络权限有关的五种</p>
<ol>
<li><p>允许应用程序改变网络状态<br>CHANGE_NETWORK_STATE</p>
</li>
<li><p>允许应用程序改变WiFi的状态<br>CHANGE_WIFI_STATE</p>
</li>
<li><p>允许应用程序改变有关网络的访问状态<br>ACCESS_NETWORK_STATE</p>
</li>
<li><p>允许应用程序访问WiFi网卡的网络信息<br>ACCESS_WIFI_STATE</p>
</li>
<li><p>允许应用程序完全使用网络（不能删除，会导致app无法运行）</p>
</li>
</ol>
<p>二、修改app入口页面去广告<br>检查AndroidManifest.xml是否同时包括<br><action android:name="android.intent.action.VIEW"><br><category android:name="android.intent.category.DEFAULT"><br>可以看到游戏的入口页面</category></action></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:=<span class="string">&quot;com.popcap.pvz2cthd360.wxapi.WXEntryActivity&quot;</span></span><br><span class="line"><span class="attr">android</span>:name=<span class="string">&quot;com.popcap.pvz2cthd360.SexyAppActivity&quot;</span></span><br></pre></td></tr></table></figure>
<p>adb shell dumpsys activity top //查看当前页面入口<br><img src="/1.png"></p>
<p>将app入口页面替换成当前入口页面（没有广告的入口页面）</p>
<h2 id="更改图标及apk名字"><a href="#更改图标及apk名字" class="headerlink" title="更改图标及apk名字"></a>更改图标及apk名字</h2><p>AndroidKiller中搜索<code>android:icon -&gt; 看到ic_launcher -&gt; 在.MF文件中搜索 -&gt; 找到icon路径</code></p>
<p>java -jar apktool d q0o0p.apk<br>目录下面生成一个dist目录，里面就是重打包之后的apk</p>
<h2 id="应用分身（修改apk包名）"><a href="#应用分身（修改apk包名）" class="headerlink" title="应用分身（修改apk包名）"></a>应用分身（修改apk包名）</h2><p>找到AndroidManifest.xml文件<br><code>package=&quot;&quot;</code>修改包名<br>修改proivder中的”android:authorities”属性值<br>注意：<br>（1）只修改包名会引发内容提供冲突<br>修改方案：<br>  修改proivder中的”android:authorities”属性值<br>（2）签名不一致导致无法运行<br>修改方案：<br>  使用相同的工具，统一进行签名<br>（3）只修改内部包名，导致程序崩溃<br>修改方案：<br>  全局修改</p>
<hr>
<h2 id="定位关键代码"><a href="#定位关键代码" class="headerlink" title="定位关键代码"></a>定位关键代码</h2><p>（1）资源反馈法<br>如：错误提示，运行提示 -&gt; 搜索字符串<br>String.xml -&gt; R.java -&gt; id -&gt;smail或IDA中搜索<br>（2）特征函数法<br>调用相关api函数完成<br>（3）顺序查看法<br>AndroidManifest.xml -&gt; 主Activity界面 -&gt; 掌握软件执行流程<br>（4）代码注入法<br>插桩（插入log/查看logcat/分析加解密）解密程序数据的时候使用<br>（5）栈跟踪法（动态调试/函数调用流程）<br>输出运行时栈调用跟踪信息，查看函数调用序列，理解方法的执行流程。</p>
<p>搜索关键信息找不到：</p>
<ul>
<li><p>字符串在so层</p>
</li>
<li><p>字符串被加密了</p>
</li>
<li><p>结合服务器，服务器返回，本地显示</p>
</li>
</ul>
<p>AndroidManifest.xml中（android：name=””）获取主页面信息 -&gt; smail文件中查找该页面 -&gt; 找到OnCreat()方法 -&gt;<br>起始位置插入代码（.locals 7 下一行，右键插入代码，toast输出，这是一个消息提示）-&gt;<br>点击保存，并进行回编译（这就是代码注入法,根据提示信息知道app是否可以逆向分析）-&gt;<br>手机端获取广告页Activity(adb shell dumpsys activity top ) -&gt; 在主页中找到广告页activity -&gt;<br>将StatrtActivity（由一个页面跳转到另一个页面）整行注释（AndroidKiller使用Shift+3注释[#号]）</p>
<h2 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h2><p>关键词有sign，signature，checkSign，signCheck，getPackageManager，getPackageInfo，verify，same等。</p>
<h2 id="DDMS-工具使用（虚拟机调试监控服务）"><a href="#DDMS-工具使用（虚拟机调试监控服务）" class="headerlink" title="DDMS 工具使用（虚拟机调试监控服务）"></a>DDMS 工具使用（虚拟机调试监控服务）</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>提供截屏</li>
<li>查看线程和堆栈信息</li>
<li>查看logcat日志<br>去广告：<br>打开DDMS -&gt; 添加过滤器 -&gt; 浏览日志信息，找到https://广告链接</li>
</ol>
<p>-&gt; 替换为127.0.0.1</p>
<h3 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h3><ul>
<li>使用mprop<br>getprop ro.product.cpu.abi<br>下载mprop :<a href="https://github.com/wpvsyou/mprop/blob/master/arm64-v8a/mprop">https://github.com/wpvsyou/mprop/blob/master/arm64-v8a/mprop</a><br>adb -s fea4b345 push mprop /data/local/tmp</li>
</ul>
<p>手机端:<br>chmod 755 mprop<br>./mprop ro.debuggable 1</p>
<ul>
<li><p>magisk(重启失效)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="comment">#adb进入命令行模式</span></span><br><span class="line">su <span class="comment">#切换至超级用户</span></span><br><span class="line">magisk resetprop ro.debuggable 1</span><br><span class="line">stop;start; <span class="comment">#一定要通过该方式重启</span></span><br><span class="line">getprop ro.debuggable <span class="comment">#显示1</span></span><br></pre></td></tr></table></figure></li>
<li><p>MagiskHide Props Config模块修改(永久有效)<br>Magisk中搜索MagiskHide Props Config模块并安装</p>
</li>
</ul>
<h2 id="log插桩调试smail代码"><a href="#log插桩调试smail代码" class="headerlink" title="log插桩调试smail代码"></a>log插桩调试smail代码</h2><h3 id="应用程序入口页面插入信息"><a href="#应用程序入口页面插入信息" class="headerlink" title="应用程序入口页面插入信息"></a>应用程序入口页面插入信息</h3><p>将apk拖入AndroidKiller<br>工程信息栏找到入口 -&gt; 找到OnCreate函数<br>在<code>.prologue</code>(代码开始的位置) 下一行插入 -&gt; 右键 -&gt; 插入代码 -&gt; log信息输出</p>
<h3 id="程序入口点插入log信息"><a href="#程序入口点插入log信息" class="headerlink" title="程序入口点插入log信息"></a>程序入口点插入log信息</h3><p>工程管理器 -&gt; AndroidMainfest.xml -&gt; application -&gt;<br>android:name= “程序入口点” -&gt; smail中找到 -&gt; OnCreat()<br>-&gt; .prologue 下面插入log信息 -&gt; DDMS添加过滤器（主要填写过滤器名字和包名信息）查看 -&gt; 根据插入的日志信息进行筛选（应用程序执行入口页面早于程序入口页面）</p>
<p><code>注意: 局部变量寄存器个数为0或不够使用时，需要进行修改，否则app会停止运行</code></p>
<h2 id="栈跟踪法（动态调试）"><a href="#栈跟踪法（动态调试）" class="headerlink" title="栈跟踪法（动态调试）"></a>栈跟踪法（动态调试）</h2><p>adb shell dumpsys activity top //获取包名<br>打开DDMS并添加过滤器（上层是被调用者，下层是调用者，从下往上调用）<br>打开AndroidKiller -&gt; 工程信息 -&gt; 入口 -&gt; 函数loadData -&gt; .prologue下面右键插入StackTrace栈跟踪</p>
<h2 id="app-去除弹窗"><a href="#app-去除弹窗" class="headerlink" title="app 去除弹窗"></a>app 去除弹窗</h2><p>AndroidKiller -&gt; 工程管理器 -&gt; 打开apktool.yml(工程配置信息) -&gt;<br>更改versionCode:’999’(版本信息是否大于当前发布的最新版本)</p>
<h2 id="Method-Profiling方法剖析"><a href="#Method-Profiling方法剖析" class="headerlink" title="Method Profiling方法剖析"></a>Method Profiling方法剖析</h2><p>基于热点分析和性能优化，除了可以记录每一个函数占用cpu的时间外，还可以跟踪所有函数调用关系，并提供比栈跟踪法更详尽的函数调用序列报告。</p>
<p>DDMS -&gt; 第五个按钮，Profilling Options -&gt;<br> 第一个默认设置过滤方法的个数，默认1000条，第二个没有过滤,选中第一个开始捕捉 -&gt; 手机端，验证码输入捕捉，输入完成后，DDMS暂停捕捉，停止以后等待一下<br> -&gt; 弹出页面（Name：函数调用流程）-&gt; find:OnClick</p>
<p> 根据DDMS中的路径AndroidKiller找到该方法<br> 当前执行方法</p>
<ul>
<li>Parent（父节点）<br>当前方法的上层调用</li>
<li>Children （子节点）<br>当前方法的下层调用</li>
</ul>
<h2 id="AndroidStudio-smalidea插件动态调试"><a href="#AndroidStudio-smalidea插件动态调试" class="headerlink" title="AndroidStudio + smalidea插件动态调试"></a>AndroidStudio + smalidea插件动态调试</h2><p>导入完整的smali代码<br>设置所需条件<br>设置断点<br>移动设备连接至PC端，运行待调试的apk<br>运行至代码处的断点时，触发断点</p>
<hr>
<h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p>什么是ART虚拟机，和JVM/DVM有什么不同？</p>
<p>首先了解JIT（Just In Time，即时编译技术）和AOT(Ahead Of Time，预编译技术)两种编译模式。</p>
<p>JIT以JVM为例，javac把程序源码编译成JAVA字节码，JVM通过逐条解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译，执行速度必然比C/C++编译后的可执行二进制字节码程序慢，为了提高执行速度，就引入了JIT技术，JIT会在运行时分析应用程序的代码，识别哪些方法可以归类为热方法，这些方法会被JIT编译器编译成对应的汇编代码，然后存储到代码缓存中，以后调用这些方法时就不用解释执行了，可以直接使用代码缓存中已编译好的汇编代码。这能显著提升应用程序的执行效率。（安卓Dalvik虚拟机在2.2中增加了JIT）<br>相对的AOT就是指C/C++这类语言，编译器在编译时直接将程序源码编译成目标机器码，运行时直接运行机器码。</p>
<p>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码</p>
<p>Dalvik执行的是dex字节码，依靠JIT编译器去解释执行，运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后在执行，但是将dex字节码翻译成本地机器码是发生在应用程序的运行过程中，并且应用程序每一次重新运行的时候，都要重新做这个翻译工作，因此，及时采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>
<p>安卓运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者重新将自己的应用直接编译成目标机器码，也就是说，应用程序仍然是一个包含dex字节码的apk文件。所以在安装应用的时候，dex中的字节码将被编译成本地机器码，之后每次打开应用，执行的都是本地机器码。移除了运行时的解释执行，效率更高，启动更快。（安卓在4.4中发布了ART运行时）</p>
<p>ART优点：<br>①系统性能显著提升<br>②应用启动更快、运行更快、体验更流畅、触感反馈更及时<br>③续航能力提升<br>④支持更低的硬件</p>
<p>ART缺点<br>①更大的存储空间占用，可能增加10%-20%<br>②更长的应用安装时间</p>
<p>总的来说ART就是“空间换时间”</p>
<hr>
<p>ART模式下基于frida框架脱壳技术原理<br>不同于传统java应用层hook dump出dex文件，而是从系统层面拦截hook到OpenMemory函数进行dump。 一般安卓加载代码都是通过classloader来装取本地代码到内存中去的。<br>ClassLoader有两种加载方式：<br>1.通过路径寻找本地代码，然后装入内存<br>基本的源码顺序是BaseDexClassLoader——&gt;DexPathList——&gt;makeDexElement——&gt;loadDexFile—&gt;dDexFile.loadDex 最后DexFile中有个native方法，OpenDexFileNative对应了DexFile_openDexFileNative方法，其中的OpenDexFileFormOat就是最主要的方法了。<br>2.直接映射到内存中去<br>4.x中DexFile.loadDex这个方法已经摒弃了，使用的是</p>
<p>native private static int openDexFile(byte[] fileContents);<br>然而这个方法在5.0中也已经摒弃了，在native层中依旧存在于/art/runtime/dex_file.cc中。其方法为OpenMemory函数。我们只需要hook 拦截到这个方法dump出dex文件就ok。下面就展开介绍下常见的几个针对这种脱壳模式的frida框架脱壳工具脚本。</p>
<hr>
<h2 id="基于Frida的工具"><a href="#基于Frida的工具" class="headerlink" title="基于Frida的工具"></a>基于Frida的工具</h2><p>FRIDA-DEXDUMP<br>github地址：<a href="https://github.com/hluwa/FRIDA-DEXDump">https://github.com/hluwa/FRIDA-DEXDump</a><br>这个工具主要是暴力搜索内存dump dex方式。<br>对于完整的dex，采用暴力搜索dexn035即可找到。 而对于抹头的dex，通过匹配一些特征来找到，然后自动修复文件头，很强大的一个脚本工具。</p>
<p>Frida-Apk-Unpack<br>github地址：<br><a href="https://github.com/hluwa/FRIDA-DEXDump">https://github.com/hluwa/FRIDA-DEXDump</a><br><a href="https://github.com/GuoQiang1993/Frida-Apk-Unpack">https://github.com/GuoQiang1993/Frida-Apk-Unpack</a><br>上面这三个工具都是优先找到OpenMemory和OpenCommon函数，在内存中，也就是app loader以后查找dex文件头dex035，然后根据dex size偏移量把dex整个dump下来。但这个工具在android7.1以上测试由于hook opencommon(libart.so中openmemory去掉了，只能用opencommon这个入口)函数，存在无法唤醒函数情况。</p>
<hr>
<h1 id="绕过检测"><a href="#绕过检测" class="headerlink" title="绕过检测"></a>绕过检测</h1><h2 id="绕过调试器检测"><a href="#绕过调试器检测" class="headerlink" title="绕过调试器检测"></a>绕过调试器检测</h2><p>没有绕过反调试的通用方法：最佳方法取决于用于防止或检测调试的特定机制以及整体保护方案<br>中的其他防御措施。例如：如果没有完整性检查，或者您已经将其停用，则修补应用程序可能是<br>最简单的方法。在其他情况下，Hook 框架或内核模块可能更可取。以下方法描述了绕过调试器检<br>测的不同方法：<br>• 修补防调试功能：通过简单地用 NOP 指令覆盖它来禁用有害行为。请注意，如果防调试机制<br>设计合理，则可能需要更复杂的补丁。<br>• 使用 Frida 或 Xposed 挂钩 Java 和本机层上的 API：处理诸如 isDebuggable 和<br>isDebuggerConnected，之类的函数的返回值以隐藏调试器。<br>• 改变环境：Android 是一个开放的环境。如果没有其他效果，则可以修改操作系统，以颠覆<br>开发人员在设计反调试技巧时所做的假设</p>
<h2 id="绕过-Root-检查"><a href="#绕过-Root-检查" class="headerlink" title="绕过 Root 检查"></a>绕过 Root 检查</h2><p>如果采用 JDB，DDMS，strace 或内核模块来跟踪 App 并了解其运行情况。通常会看到与操作系统<br>的各种可疑交互，例如运行 su 读取并获取进程列表。这些可以交互都是设备被 root 的标志。所<br>以应当一次性识别并足证 root 检查程序的运行。如果执行黑盒安全分析，应当在第一步就令 root<br>检查程序失效。<br>要绕过这些检查，可以使用下面几种技术，其中大多数是在“逆向工程和篡改”章节中介绍过的：<br>• 重命名二进制文件。例如：简单地重命名 su 二进制文件足以对抗 root 检测（注意，请不要<br>破坏初始环境！）。<br>• 卸载/ proc 以防止读取进程列表。 但有时，这不足以绕过此类检查。<br>• 用 Frida 或 Xposed 在 Javac 层和 Native 层上进行 Hook。通过伪造应用程序的返回值，隐藏<br>文件内容和进程。<br>• 使用内核模块 Hook 低等级的 API。<br>• 篡改 app 来逃避检查。</p>
<p>检查 root 检测机制时，应包括以下机制：<br>• 在应用程序中采用多种不同类似的检测机制（而不是仅采用一种机制进行检测）。<br>• 让检测机制在多个层面的 API 上运行（JavaAPI、Native 函数、汇编程序、系统调用）。<br>• 检测机制应当是原创的（不应是从 StackOverflow 或其他来源复制粘贴而来）。</p>
<p>研究 root 检测机制绕过的方法时应回答下列问题：<br>• 是否可以使用 RootCloak 等标准工具轻松绕开检测机制？<br>• 进行 root 检测需要进行静态/动态分析吗？<br>• 需要编写自定义代码吗？<br>• 成功绕过检测机制需要多长时间？<br>• 绕过检测机制有哪些困难？<br>如果缺少 root 检测或 root 检测容易被，请根据上面列出的有效性标准提出建议。这些建议可能包<br>括更多种类的检测机制，以及将现有机制与其他防御措施更好地集成。</p>
<hr>
<h2 id="app重新打包过程"><a href="#app重新打包过程" class="headerlink" title="app重新打包过程"></a>app重新打包过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#apktool反编译</span><br><span class="line">java -jar Apktool_2.5.0.jar d zwdzjs.apk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重新打包</span><br><span class="line">java -jar Apktool_2.5.0.jar b zwdzjs</span><br><span class="line"></span><br><span class="line"># 生成key</span><br><span class="line">keytool -genkey -alias q0o0p.keystore -keyalg RSA -validity 20000 -keystore q0o0p.keystore</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用上面生成的key进行签名</span><br><span class="line">jarsigner -verbose -keystore q0o0p.keystore -signedjar zwdzjs_signed.apk zwdzjs.apk q0o0p.keystore</span><br></pre></td></tr></table></figure>

<p> APK 签名方案可供选择。<br>• JAR 签名（v1 方案）。<br>• APK 签名方案 v2（v2 方案）。<br>• APK 签名方案 v3（v3 方案）。<br>安卓 7.0（API 级别 24）及以上版本支持的 v2 签名，与 v1 方案相比，安全性和性能都有所提<br>高。<br>安卓 9（API 级别 28）及以上版本支持的 V3 签名，使应用程序能够更改其签名密钥，作为<br>APK 更新的一部分。该功能通过允许同时使用新旧密钥，保证了兼容性和应用程序的持续可用<br>性。<br>对于每个签名方案，发行版构建应该总是通过其之前的所有方案进行签名。</p>
<p>首先记得去除签名，用WinRAR打开apk，找到META-INF文件夹，删除MANIFEST.MF之外的所有其他文件即可。</p>
<p>jarsigner方式只支持v1签名，apksigner方式支持v1和v2的方式。<br>v1和v2的区别，可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32115439/article/details/55520012%E3%80%82">https://blog.csdn.net/qq_32115439/article/details/55520012。</a><br>方式一：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -keystore [您的私钥存放路径] -signedjar [签名后文件存放路径] [未签名的文件路径] [您的证书名称]</span><br><span class="line">jarsigner -verbose -keystore ~/Workspace/mykeystore -signedjar ./signed.apk ./unsigned.apk xiaomi</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign --ks 密钥库名 --ks-key-alias 密钥别名 xxx.apk</span><br></pre></td></tr></table></figure>

<p>上述命令，签名后没有改变文件名称。如何判断是否签名成功？可以采用如下命令。</p>
<p>打印签名信息命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> demo.keystore -keyalg RSA -validity 20000 -keystore demo.keystore</span><br><span class="line">keytool -list -printcert -jarfile appname.apk</span><br></pre></td></tr></table></figure>

<p>加固后的APP运行流程<br>APP启动 -&gt;壳dex先加载起来 -&gt;壳负责把源dex文件读出来-&gt;壳把源dex文件解密-&gt;把解密后的dex加载进内存 源dex运行起来 </p>
<hr>
<p>梆梆&amp;爱加密java反调试绕过：<br><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-259610.htm">https://bbs.pediy.com/thread-259610.htm</a><br>基于Frida的工具：<br><a target="_blank" rel="noopener" href="https://yangrz.github.io/blog/2020/06/09/frida/">https://yangrz.github.io/blog/2020/06/09/frida/</a><br>Android ART虚拟机：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011337574/article/details/81362621">https://blog.csdn.net/u011337574/article/details/81362621</a></p>
<hr>
<p>参考:<br>Frida-API:<a target="_blank" rel="noopener" href="https://frida.re/docs/javascript-api/">https://frida.re/docs/javascript-api/</a><br>Frida:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/freeking101/article/details/106965168?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control">https://blog.csdn.net/freeking101/article/details/106965168?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/freeking101/article/details/106965168?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control">https://blog.csdn.net/freeking101/article/details/106965168?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control</a></p>
<p>Android逆向工具:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/earbao/article/details/54590040?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=1328680.54300.16164185419388575&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/earbao/article/details/54590040?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=1328680.54300.16164185419388575&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<p>Android(系统进程)安全机制:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/haoxuhong/article/details/80140911">https://blog.csdn.net/haoxuhong/article/details/80140911</a></p>
<p>脱壳机制原理:<br><a target="_blank" rel="noopener" href="https://crifan.github.io/android_app_security_crack/website/android_crack_tech/how_remove_shell_unpacking.html(%E5%A4%A7%E4%BD%AC%E5%8D%9A%E5%AE%A2)">https://crifan.github.io/android_app_security_crack/website/android_crack_tech/how_remove_shell_unpacking.html(大佬博客)</a></p>
<p>逆向思维:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012551350/article/details/98871295">https://blog.csdn.net/u012551350/article/details/98871295</a></p>
<p>面经:<br><a target="_blank" rel="noopener" href="http://smartadmin.com.cn/smartadmin/show-4913.html">http://smartadmin.com.cn/smartadmin/show-4913.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">q0o0p</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/q0o0p-wow/q0o0p-wow.github.io/2021/02/19/Android-Reverse/">https://github.com/q0o0p-wow/q0o0p-wow.github.io/2021/02/19/Android-Reverse/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/reverse/">reverse</a></div><div class="post_share"><div class="social-share" data-image="/img/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/23/packers-shelling/"><img class="prev-cover" src="/true" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">App脱壳实例</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/19/ida/"><img class="next-cover" src="/img/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">逆向基础--寄存器介绍</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/08/12/Android-payload/" title="Android-payload"><img class="cover" src="/true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-12</div><div class="title">Android-payload</div></div></a></div><div><a href="/2021/03/23/packers-shelling/" title="App脱壳实例"><img class="cover" src="/true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-23</div><div class="title">App脱壳实例</div></div></a></div><div><a href="/2021/03/29/Blackbox-tool/" title="Android安全检测工具"><img class="cover" src="/true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-29</div><div class="title">Android安全检测工具</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">q0o0p</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">60</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://q0o0p.top"><i class="q0o0p"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#App%E5%8A%A0%E5%A3%B3%E5%92%8C%E8%84%B1%E5%A3%B3"><span class="toc-number">1.</span> <span class="toc-text">App加壳和脱壳</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A3%B3"><span class="toc-number">1.1.</span> <span class="toc-text">常见的壳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%B1%E5%A3%B3%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">脱壳机制原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HOOK"><span class="toc-number">2.</span> <span class="toc-text">HOOK</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hook-startActivity-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">hook startActivity 的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Xposed"><span class="toc-number">2.2.</span> <span class="toc-text">Xposed</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Xposed%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">Xposed的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.2.2.</span> <span class="toc-text">插件开发步骤:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Xposed%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-https-q0o0p-top-2021-03-30-Xposed-hook"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">Xposed插件开发: https:&#x2F;&#x2F;q0o0p.top&#x2F;2021&#x2F;03&#x2F;30&#x2F;Xposed-hook&#x2F;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Frida"><span class="toc-number">2.3.</span> <span class="toc-text">Frida</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Frida-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.1.</span> <span class="toc-text">Frida 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frida-%E4%BD%9C%E7%94%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">Frida 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frida%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.3.</span> <span class="toc-text">Frida的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Frida%E5%AE%9E%E4%BE%8B-https-q0o0p-top-2021-03-24-cydia-hook"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">Frida实例: https:&#x2F;&#x2F;q0o0p.top&#x2F;2021&#x2F;03&#x2F;24&#x2F;cydia-hook&#x2F;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SubstrateCydia%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.4.</span> <span class="toc-text">SubstrateCydia的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">Android安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B2%99%E7%AE%B1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.1.</span> <span class="toc-text">进程沙箱隔离机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.2.</span> <span class="toc-text">应用程序签名机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.3.</span> <span class="toc-text">权限声明机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.4.</span> <span class="toc-text">访问控制机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.5.</span> <span class="toc-text">进程通信机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.6.</span> <span class="toc-text">内存通信机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SELinux"><span class="toc-number">2.4.7.</span> <span class="toc-text">SELinux</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">Android系统架构如下：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.6.</span> <span class="toc-text">经典漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Master-Key%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.6.1.</span> <span class="toc-text">Master Key漏洞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">2.7.</span> <span class="toc-text">常用调试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JADX"><span class="toc-number">2.7.1.</span> <span class="toc-text">JADX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DexExtractor"><span class="toc-number">2.7.2.</span> <span class="toc-text">DexExtractor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InDroid"><span class="toc-number">2.7.3.</span> <span class="toc-text">InDroid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drizzleDumper"><span class="toc-number">2.7.4.</span> <span class="toc-text">drizzleDumper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDA"><span class="toc-number">2.7.5.</span> <span class="toc-text">IDA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">2.8.</span> <span class="toc-text">调试与反调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B"><span class="toc-number">2.8.1.</span> <span class="toc-text">模拟器检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E8%B0%83%E8%AF%95%E7%AB%AF%E5%8F%A3%E6%A3%80%E6%B5%8B-kill%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.8.2.</span> <span class="toc-text">运行调试端口检测,kill程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8D%E7%A7%B0%E6%A3%80%E6%B5%8B"><span class="toc-number">2.8.3.</span> <span class="toc-text">进程名称检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E5%BE%AA%E6%A3%80%E6%B5%8B"><span class="toc-number">2.8.4.</span> <span class="toc-text">轮循检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self-debugger%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86"><span class="toc-number">2.8.5.</span> <span class="toc-text">self-debugger反调试原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%B1%82%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">2.8.6.</span> <span class="toc-text">java层反调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.8.7.</span> <span class="toc-text">静态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86"><span class="toc-number">2.9.</span> <span class="toc-text">代码混淆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.9.1.</span> <span class="toc-text">混淆的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProGuard"><span class="toc-number">2.9.2.</span> <span class="toc-text">ProGuard</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%B7%B7%E6%B7%86"><span class="toc-number">2.10.</span> <span class="toc-text">资源混淆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81"><span class="toc-number">2.11.</span> <span class="toc-text">签名验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI-OnLoad%E7%AE%80%E4%BB%8B"><span class="toc-number">2.11.1.</span> <span class="toc-text">JNI_OnLoad简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4"><span class="toc-number">2.13.</span> <span class="toc-text">逆向思维</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#adb%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">adb的相关使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%A4%E5%8E%BB%E5%B9%BF%E5%91%8A"><span class="toc-number">3.1.</span> <span class="toc-text">除去广告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%9B%BE%E6%A0%87%E5%8F%8Aapk%E5%90%8D%E5%AD%97"><span class="toc-number">3.2.</span> <span class="toc-text">更改图标及apk名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%88%86%E8%BA%AB%EF%BC%88%E4%BF%AE%E6%94%B9apk%E5%8C%85%E5%90%8D%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">应用分身（修改apk包名）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">3.4.</span> <span class="toc-text">定位关键代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.5.</span> <span class="toc-text">签名校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DDMS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">DDMS 工具使用（虚拟机调试监控服务）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">3.6.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95"><span class="toc-number">3.6.2.</span> <span class="toc-text">真机调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log%E6%8F%92%E6%A1%A9%E8%B0%83%E8%AF%95smail%E4%BB%A3%E7%A0%81"><span class="toc-number">3.7.</span> <span class="toc-text">log插桩调试smail代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E9%A1%B5%E9%9D%A2%E6%8F%92%E5%85%A5%E4%BF%A1%E6%81%AF"><span class="toc-number">3.7.1.</span> <span class="toc-text">应用程序入口页面插入信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E7%82%B9%E6%8F%92%E5%85%A5log%E4%BF%A1%E6%81%AF"><span class="toc-number">3.7.2.</span> <span class="toc-text">程序入口点插入log信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E8%B7%9F%E8%B8%AA%E6%B3%95%EF%BC%88%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">栈跟踪法（动态调试）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app-%E5%8E%BB%E9%99%A4%E5%BC%B9%E7%AA%97"><span class="toc-number">3.9.</span> <span class="toc-text">app 去除弹窗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Method-Profiling%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90"><span class="toc-number">3.10.</span> <span class="toc-text">Method Profiling方法剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AndroidStudio-smalidea%E6%8F%92%E4%BB%B6%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-number">3.11.</span> <span class="toc-text">AndroidStudio + smalidea插件动态调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ART%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">3.12.</span> <span class="toc-text">ART虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EFrida%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">3.13.</span> <span class="toc-text">基于Frida的工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E6%A3%80%E6%B5%8B"><span class="toc-number">4.</span> <span class="toc-text">绕过检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E8%B0%83%E8%AF%95%E5%99%A8%E6%A3%80%E6%B5%8B"><span class="toc-number">4.1.</span> <span class="toc-text">绕过调试器检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%95%E8%BF%87-Root-%E6%A3%80%E6%9F%A5"><span class="toc-number">4.2.</span> <span class="toc-text">绕过 Root 检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">app重新打包过程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/21/camera-hook/" title="hook android摄像头"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hook android摄像头"/></a><div class="content"><a class="title" href="/2021/09/21/camera-hook/" title="hook android摄像头">hook android摄像头</a><time datetime="2021-09-21T07:16:06.000Z" title="Created 2021-09-21 15:16:06">2021-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/27/cryptology/" title="app中常见的加密"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="app中常见的加密"/></a><div class="content"><a class="title" href="/2021/06/27/cryptology/" title="app中常见的加密">app中常见的加密</a><time datetime="2021-06-27T07:57:15.000Z" title="Created 2021-06-27 15:57:15">2021-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/07/miui12-android11/" title="MIUI的正确使用"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIUI的正确使用"/></a><div class="content"><a class="title" href="/2021/05/07/miui12-android11/" title="MIUI的正确使用">MIUI的正确使用</a><time datetime="2021-05-07T11:28:33.000Z" title="Created 2021-05-07 19:28:33">2021-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/06/mobile-security-top10/" title="移动安全之旅"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="移动安全之旅"/></a><div class="content"><a class="title" href="/2021/05/06/mobile-security-top10/" title="移动安全之旅">移动安全之旅</a><time datetime="2021-05-06T14:07:49.000Z" title="Created 2021-05-06 22:07:49">2021-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/23/reverse-leaning/" title="学习路线整理中..."><img src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习路线整理中..."/></a><div class="content"><a class="title" href="/2021/04/23/reverse-leaning/" title="学习路线整理中...">学习路线整理中...</a><time datetime="2021-04-23T07:52:33.000Z" title="Created 2021-04-23 15:52:33">2021-04-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/7.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2021 By q0o0p</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script></div><script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script>
- <script src="https://cdn.jsdelivr.net/gh/Akilarlxh/live2d_demo_without_api@v1.1/assets/jquery.min.js"></script> - <script defer src="https://cdn.jsdelivr.net/gh/Akilarlxh/live2d_demo_without_api@v1.1/assets/jquery-ui.min.js"></script> - <script defer data-pjax src="https://cdn.jsdelivr.net/gh/Akilarlxh/live2d_demo_without_api@v1.1/assets/autoload.js"></script>
<script src="/js/snow_small.js"></script> <script src="/js/fish.js"></script>
<script src="/js/bubble.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>