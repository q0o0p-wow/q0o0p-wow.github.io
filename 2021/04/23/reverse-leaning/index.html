<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>学习路线整理中... | q0o0p</title><meta name="author" content="q0o0p"><meta name="copyright" content="q0o0p"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="APK1.1 APK文件格式1.1.1 常见文件格式jar、apk、dex、Manifest、resource、Meta JAR  可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符.  (1) 安全性,可以对整个jar包的内容进行签名。  (2) 减少了下载时间  如果applet被打包成一个jar文件，那么所有相关的资源就可以在一个H">
<meta property="og:type" content="article">
<meta property="og:title" content="学习路线整理中...">
<meta property="og:url" content="https://github.com/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/index.html">
<meta property="og:site_name" content="q0o0p">
<meta property="og:description" content="APK1.1 APK文件格式1.1.1 常见文件格式jar、apk、dex、Manifest、resource、Meta JAR  可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符.  (1) 安全性,可以对整个jar包的内容进行签名。  (2) 减少了下载时间  如果applet被打包成一个jar文件，那么所有相关的资源就可以在一个H">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/q0o0p-wow/q0o0p-wow.github.io/img/4.jpg">
<meta property="article:published_time" content="2021-04-23T07:52:33.000Z">
<meta property="article:modified_time" content="2021-10-18T07:42:55.276Z">
<meta property="article:author" content="q0o0p">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/q0o0p-wow/q0o0p-wow.github.io/img/4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学习路线整理中...',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-18 15:42:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <link rel="stylesheet" href="/live2d-widget/waifu.css"> <link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">82</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">q0o0p</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学习路线整理中...</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-04-23T07:52:33.000Z" title="Created 2021-04-23 15:52:33">2021-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-10-18T07:42:55.276Z" title="Updated 2021-10-18 15:42:55">2021-10-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">17.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>58min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="学习路线整理中..."><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="APK"><a href="#APK" class="headerlink" title="APK"></a>APK</h1><h2 id="1-1-APK文件格式"><a href="#1-1-APK文件格式" class="headerlink" title="1.1 APK文件格式"></a>1.1 APK文件格式</h2><h3 id="1-1-1-常见文件格式jar、apk、dex、Manifest、resource、Meta"><a href="#1-1-1-常见文件格式jar、apk、dex、Manifest、resource、Meta" class="headerlink" title="1.1.1 常见文件格式jar、apk、dex、Manifest、resource、Meta"></a>1.1.1 常见文件格式jar、apk、dex、Manifest、resource、Meta</h3><ul>
<li>JAR<br>  可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符.<br>  (1) 安全性,可以对整个jar包的内容进行签名。<br>  (2) 减少了下载时间<br>  如果applet被打包成一个jar文件，那么所有相关的资源就可以在一个HTTP transaction中下载完成，而无需为每一个文件新建一个连接。<br>  (3) 压缩,可移植<br>  (4) 容易扩展(通过jar这种格式，可以和容易地将自己的程序打包提供给别人使用。)<br>  (5) 包密封(Package Sealing)被密封，来保证版本的一致性。密封可以保证一个包中的所有类都来自同一个jar文件。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    //运行一个打包为可执行 JAR 文件的应用程序</span><br><span class="line">java -jar app.jar</span><br><span class="line"></span><br><span class="line">jar -cvfM HelloWorld.jar HelloWorld.class   <span class="comment">#将HelloWorld.class文件打入jar包</span></span><br><span class="line">jar -tf HelloWorld.jar  HelloWorld.class</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>apk</strong><br>  **META-INF文件夹:**Jar文件中常见<br>  **MANIFEST.MF:**清单文件<br>  <strong>CERT.RSA:</strong> 保存着该应用程序的证书和授权信息。<br>  <strong>CERT.SF:</strong> 保存着SHA-1信息资源列表，<br>  <strong>Signature-Version:</strong> 1.0Created-By: 1.0(Android)SHA1-Digest-Manifest : wxqnEAI0UA5nO5QJ8CGMwjkGGWE &#x3D;… Name: res&#x2F; layout&#x2F; exchange_ component _back _bottom. xmlSHA1- Digest: eACjMjESj7Zkf0cBFTZ0nqWrt7w &#x3D; …Name:res&#x2F;drawable-hdpi&#x2F;SHA1-Digest: DGEqylP8W0n0iV&#x2F;ZzBx3MW0WGCA&#x3D;<br>  res: APK所需要的资源文件夹。<br>  <strong>AndroidManifest.xml:</strong> 一个传统的Android清单文件，用于描述该应用程序的名字、版本号、所需权限、注册的服务、链接的其他应用程序。该文件使用XML文件格式，可以编译为二进制的XML，使用的工具为AXMLPrinter2或apktool 。<br>  **classes.dex:**classes文件通过DEX编译后的文件格式，用于在Dalvik虚拟机上运行的主要代码部分。<br> **resources.arsc:**程序的语言文件，可以透过这软件用(AndroidResEdit等工具)来进行翻译，也可以用ApkTool等工具反编译后再开始进行软件修改。- </li>
<li><strong>dex</strong><br>① dex文件结构解析</li>
</ul>
<p><img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/2.png"><br><img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/1.png"><br>② dex数据结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>等同于uint8_t，表示1字节的无符号数</td>
</tr>
<tr>
<td>u2</td>
<td>等同于uint16_t，表示2字节的无符号数</td>
</tr>
<tr>
<td>u4</td>
<td>等同于uint32_t，表示4字节的无符号数</td>
</tr>
<tr>
<td>u8</td>
<td>等同于uint64_t，表示8字节的无符号数</td>
</tr>
<tr>
<td>sleb128</td>
<td>有符号LEB128，可变长度1~5字节</td>
</tr>
<tr>
<td>uleb128</td>
<td>无符号LEB128，可变长度1~5字节</td>
</tr>
<tr>
<td>uleb128p1</td>
<td>无符号LEB128加1，可变长度1~5字节</td>
</tr>
</tbody></table>
<ul>
<li><strong>manifest</strong><br>(1) 为应用的 Java 软件包命名。软件包名称充当应用的唯一标识符<br>(2) 描述应用的各个组件，即：构成应用的 Activity、服务（Service）、广播接收器（BroadcastReceiver）和内容提供程序（ContentProvider）。 为实现每个组件的类命名并发布其功能（例如，它们可以处理的 Intent 消息）。根据这些声明，Android 系统可以了解这组件具体是什么，以及在什么条件下可以启动它们<br>(3) 确定将托管应用组件的进程<br>(4) 声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互<br>(5) 还声明其他应用与该应用组件交互所需具备的权限<br>(6) 列出 Instrumentation类，这些类可在应用运行期间提供分析和其他信息。这些声明只会在应用处在开发和测试阶段时出现在清单文件中；它们会在应用发布之前被删除<br>(7) 声明应用所需的最低 Android API 级别<br>(8) 列出应用必须链接到的库</li>
</ul>
<p>只有<manifest>和 <application>元素是必需的，它们都必须存在并且只能出现一次。</application></manifest></p>
<ul>
<li><strong>resource</strong></li>
</ul>
<p>Resources.arsc文件格式是由一系列的chunk构成，每一个chunk均包含如下结构的ResChunk_header.</p>
<ol>
<li>chunk的基本信息</li>
</ol>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>当前这个chunk的类型</td>
<td>2字节</td>
</tr>
<tr>
<td>headerSize</td>
<td>当前这个chunk的头部大小</td>
<td>2字节</td>
</tr>
<tr>
<td>size</td>
<td>当前这个chunk的大小</td>
<td>4字节</td>
</tr>
</tbody></table>
<ol start="2">
<li>资源索引表的头部信息</li>
</ol>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>标准的Chunk头部信息格式</td>
<td>8字节：0x0002</td>
</tr>
<tr>
<td>packageCount</td>
<td>被编译的资源包的个数，Apk中可以包含多个资源包，默认就1个</td>
<td>4字节</td>
</tr>
</tbody></table>
<ol start="3">
<li>资源项的值字符串资源池</li>
</ol>
<p>紧跟着资源索引表头部的是资源项的值字符串资源池,这个字符串资源池包含了所有的在资源包里面所定义的资源项的值字符串,字符串资源池头部的结构如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>标准的Chunk头部信息格式</td>
<td>8字节：0x0001</td>
</tr>
<tr>
<td>stringCount</td>
<td>字符串的个数</td>
<td>4字节</td>
</tr>
<tr>
<td>styleCount</td>
<td>字符串样式的个数</td>
<td>4字节</td>
</tr>
<tr>
<td>flags</td>
<td>字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值</td>
<td>4字节</td>
</tr>
<tr>
<td>stringsStart</td>
<td>字符串内容块相对于当前Chunk头部的距离</td>
<td>4字节*stringCount</td>
</tr>
<tr>
<td>stylesStart</td>
<td>字符串样式块相对于当前Chunk头部的距离</td>
<td>4字节*styleCount</td>
</tr>
<tr>
<td>stringOffsetArray</td>
<td>每个字符串相对于stringsStart位置的偏移</td>
<td>4字节*stringCount</td>
</tr>
<tr>
<td>styleOffsetArray</td>
<td>每个style串相对于stylesStart位置的偏移</td>
<td>4字节*stylesCount</td>
</tr>
<tr>
<td>strings</td>
<td>字符串内容池</td>
<td>每个串的前2个字节标识字符串长度，utf8的字符串以0x00结尾，长度不包含结束符</td>
</tr>
<tr>
<td>styles</td>
<td>样式串内容池</td>
<td></td>
</tr>
<tr>
<td><code>字符串的长度计算比较特殊：length = byte[1] &amp; 0x7f，并且长只包含有效字符的长度，不包含结束符0x00。</code></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li>Package数据块</li>
</ol>
<p>接着资源项的值字符串资源池后面的部分就是Package数据块,这个数据块记录编译包的元数据,头部结构如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>标准的Chunk头部信息格式</td>
<td>8字节：0x0200</td>
</tr>
<tr>
<td>pkgId</td>
<td>用户包的值Package Id为0X7F,系统资源包的Package Id为0X01</td>
<td>4字节</td>
</tr>
<tr>
<td>packageName</td>
<td>包名</td>
<td>128*2字节</td>
</tr>
<tr>
<td>typeString</td>
<td>类型字符串资源池 相对头部的偏移</td>
<td>4字节</td>
</tr>
<tr>
<td>lastPublicType</td>
<td>最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值</td>
<td>设置为类型字符串资源池的元素个数</td>
</tr>
<tr>
<td>keyStrings</td>
<td>资源项名称字符串相对头部的偏移</td>
<td>4字节</td>
</tr>
<tr>
<td>lastPublicKey</td>
<td>最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，资源项名称字符串资源池的元素个数</td>
<td>4字节</td>
</tr>
</tbody></table>
<p>PackageChunk数据块头部0x0120字节 (8+4+128*2+16+4 &#x3D; 0120 最后4字节无用)，数据块部分包含：</p>
<table>
<thead>
<tr>
<th>DataBlock</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>TypeStringPool</td>
<td>类型字符串 资源池</td>
</tr>
<tr>
<td>KeyStringPool</td>
<td>资源项名称字符串</td>
</tr>
<tr>
<td>ResTableTypeSpec</td>
<td>类型规范数据块</td>
</tr>
<tr>
<td>ResTableTypeInfo</td>
<td>类型资源项数据块</td>
</tr>
</tbody></table>
<ol start="5">
<li>类型规范数据块 RES_TABLE_TYPE_SPEC_TYPE</li>
</ol>
<p>类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。其数据块头部结构如下。</p>
<p>DataBlock   含义<br>header  标准的Chunk头部信息格式  8字节：0x0202<br>typeId  标识资源的Type ID,Type ID是指资源的类型ID，资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID   1字节<br>res0    保留,始终为0 1字节<br>res1    保留,始终为0 2字节<br>entryCount  等于本类型的资源项个数,指名称相同的资源项的个数。   4字节<br>entryConfigs    配置项数组   entryConfigs * 4字节<br>6. 资源类型项数据块 RES_TABLE_TYPE_INFO_TYPE<br>类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。其数据块头部结构如下</p>
<p>DataBlock   含义<br>header  标准的Chunk头部信息格式  8字节：0x0201<br>typeId  标识资源的Type ID    1字节<br>res0    保留,始终为0 1字节<br>res1    保留,始终为0 2字节<br>entryCount  等于本类型的资源项个数,指名称相同的资源项的个数    4字节<br>entriesStart    等于资源项数据块相对头部的偏移值    4字节<br>resConfig   指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等，是union类型    大小由ResTableConfig#size字段指定，正常是56个字节<br>entryOffsets    属于当前InfoChunk的Entry偏移数组 entryCount * 4字节<br>tableEntries    具体的Entry定义，根据ResTableEntry#flags区分类型：&#x3D;FLAG_COMPLEX表示ResTableMapEntry，否则为ResTableValueEntry  根据实际的类型确定<br>如果检查到 entryOffsets[i] &#x3D;&#x3D; 0xffffffffL 表示这个位置没有entry，应该跳过继续读取下一个。这个地方还要明确一下 RES_TABLE_TYPE_SPEC_TYPE 和 RES_TABLE_TYPE_INFO_TYPE 这两种TypeChunk的关系，下面的表格是按文件流的顺序解析得到结果，可以清楚地说明问题：</p>
<table>
<thead>
<tr>
<th>SequenceId</th>
<th>ChunkType</th>
<th>TypeID</th>
<th>TypeName</th>
<th>EntryCount</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>RES_TABLE_TYPE_SPEC_TYPE</td>
<td>0x01</td>
<td>attr</td>
<td>228</td>
</tr>
<tr>
<td>1</td>
<td>RES_TABLE_TYPE_INFO_TYPE</td>
<td>0x01</td>
<td>attr</td>
<td>228</td>
</tr>
<tr>
<td>2</td>
<td>RES_TABLE_TYPE_SPEC_TYPE</td>
<td>0x02</td>
<td>drawable</td>
<td>95</td>
</tr>
<tr>
<td>3</td>
<td>RES_TABLE_TYPE_INFO_TYPE</td>
<td>0x02</td>
<td>drawable</td>
<td>95</td>
</tr>
<tr>
<td>4</td>
<td>RES_TABLE_TYPE_SPEC_TYPE</td>
<td>0x02</td>
<td>drawable</td>
<td>95</td>
</tr>
<tr>
<td>5</td>
<td>RES_TABLE_TYPE_INFO_TYPE</td>
<td>0x02</td>
<td>drawable</td>
<td>95</td>
</tr>
<tr>
<td>6</td>
<td>RES_TABLE_TYPE_SPEC_TYPE</td>
<td>0x02</td>
<td>drawable</td>
<td>95</td>
</tr>
<tr>
<td>7</td>
<td>RES_TABLE_TYPE_INFO_TYPE</td>
<td>0x02</td>
<td>drawable</td>
<td>95</td>
</tr>
<tr>
<td>8</td>
<td>RES_TABLE_TYPE_SPEC_TYPE</td>
<td>0x03</td>
<td>mipmap</td>
<td>1</td>
</tr>
<tr>
<td>9</td>
<td>RES_TABLE_TYPE_INFO_TYPE</td>
<td>0x03</td>
<td>mipmap</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>RES_TABLE_TYPE_SPEC_TYPE</td>
<td>0x03</td>
<td>mipmap</td>
<td>1</td>
</tr>
<tr>
<td>11</td>
<td>RES_TABLE_TYPE_INFO_TYPE</td>
<td>0x03</td>
<td>mipmap</td>
<td>1</td>
</tr>
<tr>
<td>12</td>
<td>RES_TABLE_TYPE_SPEC_TYPE</td>
<td>0x03</td>
<td>mipmap</td>
<td>1</td>
</tr>
<tr>
<td>13</td>
<td>RES_TABLE_TYPE_INFO_TYPE</td>
<td>0x03</td>
<td>mipmap</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c</td>
<td>layout anim string dimen style bool color id interger</td>
<td>…</td>
</tr>
</tbody></table>
<p><code>RES_TABLE_TYPE_SPEC_TYPE 的数量和当前APP使用到的资源类型数相同（attr、drawable、mipmap、layout、anim、string、dimen、style、bool、color、id、interger、xml、raw、array、menu），每个RES_TABLE_TYPE_SPEC_TYPE块之后都会跟着若干个RES_TABLE_TYPE_INFO_TYPE块，而具体的数量实际上对应的就是这种类型的资源有几种配置。</code></p>
<p>最后再看一下最后一列的EntryCount，如果把每种RES_TABLE_TYPE_SPEC_TYPE的EntryCount加起来，总数正好就是public.xml中&lt;public …&#x2F;&gt;的条目数量。</p>
<p>不能保证每个资源都正好提供N种类型，比如说mipmap类型的图片资源，a图片提供了全部配置hdpi&#x2F;mdpi&#x2F;xhdpi&#x2F;xxhdpi&#x2F;xxxhdpi，b图片只提供了mdpi&#x2F;xxhdpi，那这种差异就由entryOffsets[i]数组的具体位置来标识了，如果 entryOffsets[i]&#x3D;&#x3D;0xffffffffL 就意味着这种类型的资源在当前这种配置下没有提供，读取时应该忽略。因为具体的资源Entry在文件中都是紧密排列的，所以同一个资源在不同配置之间的偏移下标不一定相同，完全取决于其他资源配置缺失的情况。</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>Offset[] for A</th>
<th>Offset[] for B</th>
</tr>
</thead>
<tbody><tr>
<td>hdpi</td>
<td>0x111111</td>
<td>0xffffffffL 缺失</td>
</tr>
<tr>
<td>mhdpi</td>
<td>0x111111</td>
<td>0x111222</td>
</tr>
<tr>
<td>xhdpi</td>
<td>0x120000</td>
<td>0x111333</td>
</tr>
<tr>
<td>xxmhdpi</td>
<td>0x110000</td>
<td>0xffffffffL 缺失</td>
</tr>
<tr>
<td>xxxmhdpi</td>
<td>0x120000</td>
<td>0xffffffffL 缺失</td>
</tr>
</tbody></table>
<p>这个具体运行一下Demo代码就知道了，RES_TABLE_TYPE_SPEC_TYPE 和 RES_TABLE_TYPE_INFO_TYPE 这两个Chunk应该算是最复杂的了，搞清楚后下一步生成public.xml就方便了。</p>
<ol start="7">
<li>生成public.xml<br>构造public.xml要提供下面几个Entry属性：</li>
</ol>
<p>属性  含义  保存字段<br>属性类型名称  在ResTableTypeInfoChunk中根据typeId索引从typeStringPool获取：atrr&#x2F;drawble&#x2F;mipmap…<br>属性名称    在ResTableEntry中根据key.index索引从keyStringPool获取，具体在子类实现    ResTableEntry#key#index<br>资源包ID   0x01系统资源，0x7f用户资源，由PackageChunk保存   ResTablePackageChunk#pkgId<br>资源类型ID  [0x01, 0x10]下标从1开始，共16种，保存在对应的TypeChunk中    ResTableTypeInfoChunk#typeId<br>资源ID    Entry所在的数组下标，顺序从文件读取Entry的时候记录在具体的ResTableEntry中    ResTableEntry#entryId<br>上面提到同一种类型的资源对应的 RES_TABLE_TYPE_INFO_TYPE_CHUNK 会有多个，个数等于配置最多的资源类型数，同一种资源的ID是相同的，所以要避免产生重复的Entry，同时对于配置缺失的情况，要使用其他有配置的Chunk来补充。所以格式化输出时对于同一种资源，需要从多个同类别的 RES_TABLE_TYPE_INFO_TYPE_CHUNK 中找到一个非空的，顺序构造publix.xml。</p>
<p>public.xml文件中的id是4字节的16进制数，由pkgId, typeId, entryId合成：id &#x3D; pkgId &lt;&lt; 24 | typeIdId &lt;&lt; 16 | (entryId &amp; 0xffff)，最后就是构造类似<public type="attr" name="drawerArrowStyle" id="0x7f010000">这样的Entry项了，可以和apktool反编译出来的对比，应该是完全相同的。</public></p>
<ol start="8">
<li>由public.xml的key找到value值</li>
</ol>
<ul>
<li><strong>Meta</strong><br>MANIFEST.MF、CERT.SF、INDEX.LIST、CERT.RSA</li>
</ul>
<p>MANIFEST.MF（摘要文件）：程序遍历APK包中的所有文件，对非文件夹非签名文件的文件，逐个用SHA1生成摘要信息，再用Base64进行编码。如果APK包的文件被修改，在APK安装校验时，被修改的文件与MANIFEST.MF的校验信息不同，程序将无法正常安装。</p>
<p>CERT.SF（对摘要文件的签名文件）：对于生成的MANIFEST.MF文件利用SHA1-RSA算法对开发者的私钥进行签名。在安装时只有公共密钥才能对其解密。解密之后将其与未加密的摘要信息进行比对，如果相符则文件没有被修改。</p>
<p>INDEX.LIST APK索引文件目录</p>
<p>CERT.RSA   保存公钥、加密算法等信息。</p>
<p>在APK进行安装时，可以通过MANIFEST.MF文件开始的环环相扣来保证APK的安全性。</p>
<h3 id="1-1-2-静态分析工具Jeb、Jadx、GDA、010editor"><a href="#1-1-2-静态分析工具Jeb、Jadx、GDA、010editor" class="headerlink" title="1.1.2 静态分析工具Jeb、Jadx、GDA、010editor"></a>1.1.2 静态分析工具Jeb、Jadx、GDA、010editor</h3><h3 id="1-1-3-熟悉Smali语言的指令格式、寄存器、数据-x2F-流程等操作等指令集"><a href="#1-1-3-熟悉Smali语言的指令格式、寄存器、数据-x2F-流程等操作等指令集" class="headerlink" title="1.1.3 熟悉Smali语言的指令格式、寄存器、数据&#x2F;流程等操作等指令集"></a>1.1.3 熟悉Smali语言的指令格式、寄存器、数据&#x2F;流程等操作等指令集</h3><ol>
<li>指令格式</li>
</ol>
<ul>
<li><p>baksmali将dex文件反编译成smali文件</p>
</li>
<li><p>smali文件头三行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class&lt;访问权限&gt;[修饰符]&lt;类名&gt;</span><br><span class="line">.super&lt;父类名&gt;</span><br><span class="line">.<span class="built_in">source</span>&lt;源文件名&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>静态字段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.field &lt;访问权限&gt; static [修饰关键字]&lt;字段名&gt;:&lt;字段类型&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>实例字段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.field &lt;访问权限&gt; [修饰关键字]&lt;字段名&gt;:&lt;字段类型&gt;</span><br></pre></td></tr></table></figure>
<p>  修饰关键字:<br>  synthetic : 表名它是合成的<br>  字段名<br>  sn: 字符串类型</p>
</li>
<li><p>直接方法(Smali中的函数)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;</span><br><span class="line">    &lt;.<span class="built_in">local</span>&gt;  <span class="comment">#局部变量个数</span></span><br><span class="line">    [.parameter] <span class="comment">#.parameters -&gt; 指定参数个数不同,.parameter -&gt; 使用一个参数</span></span><br><span class="line">    [.prologue] <span class="comment"># 代码开始处,混淆以后一般会去除</span></span><br><span class="line">    [.line] <span class="comment"># 指定代码体行号,混淆后可能去除</span></span><br><span class="line">    &lt;代码体&gt;</span><br><span class="line">    .end method</span><br></pre></td></tr></table></figure></li>
<li><p>虚方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.virtual methods</span><br></pre></td></tr></table></figure></li>
<li><p>接口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.implments &lt;接口名&gt; </span><br></pre></td></tr></table></figure></li>
<li><p>注解</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.annotations [注解类型] &lt;注解类名&gt;</span><br><span class="line">    [注解字段 = 值]</span><br><span class="line">.end annotations</span><br></pre></td></tr></table></figure>
<p>  注解作用范围可以是类、方法、字段.<br>  类: smali文件中<br>  方法或字段: 方法或字段定义中</p>
</li>
<li><p>内部类<br>  包含内部类的反编译后会出现两个文件<br>  Outer.samli<br>  Outer$Inner.smali<br>  this$0: 内部类自动保留的一个指向所在外部类的引用, 0表示层数,在里面一层就+1<br>  this$X: 被指定了synthetic属性,表明是被编译合成<br>  注: 对于非静态方法,会隐含使用p0寄存器当做类的this引用.如p0表示MainActivity$x自身的引用,<br>  p1:表示MainActivity的引用,p2:表示sn字符串的引用</p>
</li>
<li><p>监听器()<br>  <code>临时使用一次,没有复用价值,多采用匿名内部类使用</code><br>  点击事件响应OnClickListener,长按事件响应OnLongClickListener,ListView列表点击事件响应OnItemSelected-Listener…</p>
</li>
</ul>
<ol start="2">
<li><p>寄存器</p>
<ul>
<li>本地寄存器以v开头数字结尾，如：v0，v1…</li>
<li>参数寄存器以p开头数字结尾，如：p0，p1…</li>
<li>p0 不一定是函数中的第一个参数，在非static函数中，p0就是“this”的意思，后面的才为函数参数</li>
</ul>
</li>
<li><p>Smali中的数据类型<br> v        void只能用于返回值类型<br> Z        boolean类型<br> B        byte类型<br> S        shot类型<br> C        char类型<br> I          int类型<br> J         long类型<br> F        float类型<br> D        double类型<br> 数组类型：   [  <br> [后面跟着基本数据类型<br> 如：float []    &#x3D;&#x3D;&#x3D;&gt;    [F<br> char [][]    &#x3D;&#x3D;&#x3D;&gt;      [[C<br> 对象类型：L&lt;包名&gt;&#x2F;&lt;类名&gt;;<br> 分号表示对象结束<br> String对象 &#x3D;&#x3D;&#x3D;&gt; Ljava&#x2F;lang&#x2F;String;<br> 内部类前面加 “ $ ” 符号：L&lt;包名&gt;&#x2F;&lt;类名&gt;$&lt;内部类名&gt;;</p>
</li>
<li><p>Smali中的成员变量<br> 格式：.field [访问权限] [修饰关键字] &lt;变量名&gt;:&lt;数据类型&gt;<br> 成员变量的获取指令：iget、sget、iget-boolean、sget-boolean、iget-object、sget-object等<br> 成员变量的操作指令：iput、sput、iput-boolean、sput-boolean、iput-object、sput-object等<br> 除了带有-object和-boolean之外的指令操作的是基本数据类型</p>
<p> get指令的使用：<br> 如：sget-object v0, Lcom&#x2F;aaa;-&gt;ID:Ljava&#x2F;lang&#x2F;String;<br> 表示的是获取String类型的ID变量的值，并将其存放到v0寄存器中<br> 前面为该变量所属类的类型，在冒号后面表示变量的数据类型，“-&gt;”表示所属关系<br> iget-object v0,p0,Lcom&#x2F;aaa;-&gt;view:Lcom&#x2F;aaa&#x2F;view;<br> p0为该变量所在类的实例，即“this”<br> 获取数组的话，用aget-object<br> put指令的使用：<br> const&#x2F;4 v1, 0x0<br> sput-object v3, Lcom&#x2F;aaa;-&gt;timer:Lcom&#x2F;aaa&#x2F;timer;    &#x3D;&#x3D;&#x3D;&gt;     this.timer&#x3D;null;<br> 因为给object对象赋值，所以为null<br> .local v0, args:Landroid&#x2F;os&#x2F;Message;<br> const&#x2F;4 v1, 0x12<br> iput v1, v0, Landroid&#x2F;os&#x2F;Message;-&gt;what:I    &#x3D;&#x3D;&#x3D;&gt;     args.what&#x3D;18;<br> 实例化对象Message为args并存放在寄存器v0中，给v1赋值为0x12，然后使用iput将v1的值赋给args对象的what属性</p>
</li>
<li><p>其他其他基本语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.invoke-super      <span class="comment">#调用父类方法</span></span><br><span class="line">const/high16 v0, 0xadf1     <span class="comment">#将0xadf1存放到寄存器v0中</span></span><br><span class="line">invoke-direct      <span class="comment">#调用函数</span></span><br><span class="line">return-void       <span class="comment">#函数返回void</span></span><br><span class="line">new-instance      <span class="comment">#创建实例</span></span><br><span class="line">iput-object      <span class="comment">#给对象赋值</span></span><br><span class="line">iget-object      <span class="comment">#调用对象</span></span><br><span class="line">invoke-static       <span class="comment">#调用静态函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>Smali中的条件分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if-eq v1, v2:cond_*    ===&gt; 如果v1=v2则跳转到:cond_*</span><br><span class="line">if-ne v1, v2:cond_*    ===&gt; 如果v1≠v2则跳转到:cond_*</span><br><span class="line">if-lt v1, v2:cond_*      ===&gt; 如果v1&lt;v2则跳转到:cond_*</span><br><span class="line">if-le v1, v2:cond_*     ===&gt; 如果v1&lt;=v2则跳转到:cond_*</span><br><span class="line">if-ge v1, v2:cond_*    ===&gt; 如果v1&gt;=v2则跳转到:cond_*</span><br><span class="line">if-gt v1, v2:cond_*     ===&gt; 如果v1&gt;v2则跳转到:cond_*</span><br><span class="line">if-eqz v1:cond_*        ===&gt; 如果v1=0则跳转到:cond_*</span><br><span class="line">if-nez v1:cond_*        ===&gt; 如果v1≠0则跳转到:cond_*</span><br><span class="line">if-ltz v1:cond_*          ===&gt; 如果v1&lt;0则跳转到:cond_*</span><br><span class="line">if-lez v1:cond_*         ===&gt; 如果v1&lt;=0则跳转到:cond_*</span><br><span class="line">if-gtz v1:cond_*         ===&gt; 如果v1&gt;0则跳转到:cond_*</span><br><span class="line">if-gez v1:cond_*        ===&gt; 如果v1&gt;=0则跳转到:cond_*</span><br></pre></td></tr></table></figure></li>
<li><p>Smali中的函数调用<br> 函数分为两种：direct和virtual<br> <code>direct method表示private.   virtual method表示public、protected</code><br> 在函数调用时有：invoke-direct、invoke-virtual、invoke-static、invoke-super等<br> 当参数多于4个的时候使用：invoke-xxx&#x2F;range<br> invoke-static：用于调用静态函数<br> invoke-static {}, Lcom&#x2F;aaa;-&gt;Check()Z<br>     {}：里面的东西表示传入函数的实例+参数列表，由于该static函数不需要任何参数所以里面为空<br>     const-string v0, “NIUBI”<br>     invoke-static {v0}, Ljava&#x2F;lang&#x2F;System;-&gt;loadLibrary(Ljava&#x2F;lang&#x2F;String;)V<br>         这是调用static void System.loadLibrary(String)方法，传入的参数为“NIUBI”<br> invoke-super：调用父类方法，一般用于调用onCreate、onDestroy等方法<br> invoke-direct：调用private函数<br> invoke-direct {p0}, Landroid&#x2F;app&#x2F;TabActivity;-&gt;<init>()V<br> 这里的<init>就是定义在TabActivity中的private函数<br> invoke-virtual：调用的是public、protected函数<br> sget-object v0, Lcom&#x2F;aaa;-&gt;bbb:Lcom&#x2F;ccc;<br> invoke-virtual {v0, v1}, Lcom&#x2F;ccc;-&gt;Message(Ljava&#x2F;lang&#x2F;Object;)V<br> v0是Lcom&#x2F;ccc<br> v1是传给Message方法的Ljava&#x2F;lang&#x2F;Object;参数<br> public void ccc.Message(Object)<br> invoke-xxxx&#x2F;range：当方法的参数多于4个的时候使用<br> 在调用函数的时候通常会有返回结果，如果返回值非void，则需要使用<br> move-result （返回基本数据类型）和move-result-object （返回对象）<br> const-string v0, “Eric”<br> invoke-static {v0}, Lcmb&#x2F;pbi;-&gt;t(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;<br> move-result-object v2<br> v2就保存了t方法的返回值String类型</init></init></p>
</li>
</ol>
<h3 id="1-1-4-配置调试环境并掌握常见的动态调试方法如代码注入、栈追踪、DDMS"><a href="#1-1-4-配置调试环境并掌握常见的动态调试方法如代码注入、栈追踪、DDMS" class="headerlink" title="1.1.4 配置调试环境并掌握常见的动态调试方法如代码注入、栈追踪、DDMS"></a>1.1.4 配置调试环境并掌握常见的动态调试方法如代码注入、栈追踪、DDMS</h3><ol>
<li>代码注入<br><code>插桩时注意：不要影响程序上下文，即插入的代码中，不能影响下面代码中使用的寄存器或者变量。</code></li>
</ol>
<ul>
<li>toast 弹框提示注入<br>  const-string v0, “键入Toast提示”</li>
<li>log 日志注入<br>  const-string v0, “键入log提示”<br>  invoke-static {v0}, Lcom&#x2F;android&#x2F;killer&#x2F;log;-&gt;LogStr(Ljava&#x2F;lang&#x2F;String;)V<br> 结合DDMS的方法剖析进行log过滤</li>
</ul>
<ol start="2">
<li>栈追踪<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栈跟踪</span></span><br><span class="line">new-instance v0, Ljava/lang/Exception;</span><br><span class="line">const-string v1, <span class="string">&quot;print trace&quot;</span></span><br><span class="line">invoke-direct &#123;v0, v1&#125;, Ljava/lang/Exception; -&gt;&lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">invoke-virtual &#123;v0&#125;, Ljava/lang/Exception; -&gt;printStackTrace()V</span><br></pre></td></tr></table></figure>
回编译 apk，安装，打开安装好的 apk 和 ddms 查看</li>
<li>DDMS(monitor)<br>先使用包名进行过滤</li>
</ol>
<h2 id="1-2-Java-hook"><a href="#1-2-Java-hook" class="headerlink" title="1.2 Java hook"></a>1.2 Java hook</h2><h3 id="1-2-1-了解JVM的基本原理如编译执行流程、虚拟机、内存、堆栈、垃圾回收"><a href="#1-2-1-了解JVM的基本原理如编译执行流程、虚拟机、内存、堆栈、垃圾回收" class="headerlink" title="1.2.1 了解JVM的基本原理如编译执行流程、虚拟机、内存、堆栈、垃圾回收"></a>1.2.1 了解JVM的基本原理如编译执行流程、虚拟机、内存、堆栈、垃圾回收</h3><ul>
<li><ol>
<li>JVM基本介绍<br>Java虚拟机（JVM）是5261Java Virtual Machine的缩写,通过仿真模拟各种计算机功能模拟来实现的。<br>Java虚拟机有自己完善的硬件架构,如处理器、堆栈、寄存器等,还具有相应的指令系统。</li>
</ol>
</li>
</ul>
<p> <strong>Java的编译和执行</strong><br> <img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/6.png"><br> JVM被分为三个主要的子系统<br>（1）类加载器子系统<br>    加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。<br>• 加载<br>    加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：<br>    ① 通过一个类的全限定名来获取其定义的二进制字节流。<br>    ② 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>    ③ 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<pre><code>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
</code></pre>
<p>• 连接<br>    1）验证：确保被加载的类的正确性<br>    验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：<br>    <em>文件格式验证</em>：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。<br>   <em>元数据验证</em>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。<br>    <em>字节码验证</em>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<br>    <em>符号引用验证</em>：确保解析动作能正确执行。<br>    验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<pre><code>2）准备：为类的静态变量分配内存，并将其初始化为默认值
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
    ① 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
    ② 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
假设一个类变量的定义为：public static int value = 3；
那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器&lt;clinit&gt;（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行
3）解析：把类中的符号引用转换为直接引用
    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。
    直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
</code></pre>
<p>• 初始化<br>    类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说字节码）。这里所有的静态变量会被赋初始值, 并且静态块将被执行。<br>    java中，对于初始化阶段，有且只有**以下五种情况才会对要求类立刻初始化：<br>    ① 使用new关键字实例化对象、访问或者设置一个类的静态字段（被final修饰、编译器优化时已经放入常量池的例外）、调用类方法，都会初始化该静态字段或者静态方法所在的类；<br>    ② 初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化；<br>    ③ 使用java.lang.reflect包的方法进行反射调用的时候，如果类没有被初始化，则要先初始化；<br>    ④ 虚拟机启动时，用户会先初始化要执行的主类（含有main）；<br>    ⑤ jdk 1.7后，如果java.lang.invoke.MethodHandle的实例最后对应的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，并且这个方法所在类没有初始化，则先初始化；<br>（2）运行时数据区<br>    运行时数据区域被划分为5个主要组件：<br>    ① 方法区 (线程共享) 常量 静态变量 JIT(即时编译器)编译后代码也在方法区存放<br>    ② 堆内存(线程共享) 垃圾回收的主要场地<br>    ③ 程序计数器 当前线程执行的字节码的位置指示器<br>    ④ Java虚拟机栈(栈内存) :保存局部变量,基本数据类型以及堆内存中对象的引用变量<br>    ⑤ 本地方法栈 (C栈):为JVM提供使用native方法的服务</p>
<p>（3）执行引擎<br>    分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐段执行.<br>    ① 解释器: 解释器能快速的解释字节码，但执行却很慢。 解释器的缺点就是,当一个方法被调用多次，每次都需要重新解释。<br>    ② 编译器：JIT编译器消除了解释器的缺点。执行引擎利用解释器转换字节码，但如果是重复的代码则使用JIT编译器将全部字节码编译成本机代码。<br>    编译和解释执行的区别是：是否产生中间本地机器码。即时编译生成机器相关的中间码，可重复执行缓存效率高。<br>    解释器（减少内存）和编译器（提高速度）<br>    编译包括两种情况：<br>    1，源码编译成字节码<br>    2，字节码编译成本地机器码（符合本地系统专属的指令）<br>    解释执行也包括两种情况：<br>    1，源码解释执行<br>    2，字节码解释执行<br>    解释执行直接执行字节码，重复执行需要重复解释。</p>
<p><code>JAVA：先编译后解释（java源文件--javac编译--.class文件/与平台无关的字节码--JVM解释执行--特定平台的机器码）。javac编译器不需要面向任何具体的平台，只需要面向JVM，不同平台上JVM是不同的，但这些不同的JVM都提供了相同的接口，从而保证了Java的跨平台性。</code></p>
<p><em>计算机语言的(执行方式)分为编译型和解释型两种</em>：<br>　　编译型语言：指使用专门的编译器，针对特定平台（操作系统）将某种高级语言源代码一次性翻译成可以被该平台硬件执行的机器码（包括机器指令和操作数），并包装成改平台所能识别的可执行性程序的格式，这个转换过程称为编译（Compile）。编译结束后，可能需要对编译好的目标代码进行链接。优点是运行效率高，组装的时候可以实现低层次的代码复用；缺点是不能跨平台。<br>　　解释型语言：指使用专门的解释器，对源程序逐行解释成特定的平台上的机器码并立即执行的语言。优点是跨平台比较容易，只需要提供特定平台上的解释器即可，每个平台上的解释器负责将源程序解释成特定平台的机器指令。缺点是程序执行效率低，每次执行程序都需要进行一次编译。<br>    编译型语言：C、C++、Objective-C、Pascal。（提高速度，复用）<br>　　半编译型语言：Visual Basic<br>　　解释型语言：Ruby、Python（减少内存，跨平台）</p>
<p><strong>JVM的编译器可以分为三个编译器</strong>：<br>（1）前端编译器：把.java转变为.class的过程。如Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。<br>（2）后端编译器:它在程序运行期间将字节码转变成机器码（现在的Java程序在运行时基本都是解释执行加编译执行）, 如HotSpot虚拟机自带的JIT（Just In Time Compiler）编译器（分Client端和Server端）。<br><code>JIT: 当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器</code><br>（3）AOT编译器：静态提前编译器（AOT，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码，如GCJ、Excelsior JET等，这类编译器我们应该比较少遇到。</p>
<ul>
<li><ol start="2">
<li><strong>JVM的组成：</strong>(虚拟机)<br>JVM是由类加载器子系统、bai运行时数据区、执du行引擎以及本地方法接口组成。<br>jvm的生命周期一个运行时的的java虚拟机实例的天职就是运行一个java程序。</li>
</ol>
</li>
</ul>
<p><em>JVM内存空间包含</em>： (内存)<br>方法区、java堆、java栈、本地方法栈。<br><img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/3.png"><br>    1、类加载子系统：负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。</p>
<pre><code>2、方法区：就是存放类信息、运行时常量池信息、包括字符串字面量和数字常量。

3、java堆：在虚拟机启动的时候建立，它是java程序最主要的内存工作区域。几乎所有的java对象实例都存放在java堆中。堆空间是所有线程共享的，这是一块与java应用密切相关的内存空间。
4、直接内存：是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。

5、java栈：每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着帧信息，java栈中保存着局部变量、方法参数，同时和java方法的调用、返回密切相关。

6、本地方法栈和java栈非常类似，最大的不同在于java栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法（通常使用C编写）

7、**垃圾回收系统**是java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的，也就是说，java中没有类似free()或者delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括java堆、方法区和直接内存中的全自动化管理。     

8、PC（Program Counter）寄存器也是每一个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined

9、执行引擎是java虚拟机的最核心组件之一，它负责执行虚拟机的字节码，现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行。
</code></pre>
<ul>
<li><ol start="3">
<li><strong>java堆栈</strong></li>
</ol>
</li>
<li>(1) java堆<br> java堆<br>    java堆是和应用程序关系最为密切的内存空间，几乎所有的对象都存放在堆上。并且java堆是完全自动化管理的，通过垃圾回收机制，垃圾对象会被自动清理，而不需要显示的释放。</li>
</ul>
<p>   根据java回收机制的不同，java堆有可能拥有不同的结构。最为常见的一种构成是将整个java堆分为新生代和老年代(默认比例为：新生代占堆空间的1&#x2F;3、老年代占堆空间2&#x2F;3)。其中新生代存放新生对象或者年龄不大的对象，老年代则存放老年对象。新生代又可以分为eden区、s0区、s1区(默认比例为：8:1:1)，s0区和s1区也被称为from和to区，他们是两块大小相同、可以互换角色的内存空间。<br><img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/4.png"><br>新生代几乎是所有JAVA对象出生的地方，JAVA对象申请的内存和存放都是在这个地方。在绝大多数情况下，对象首先分配在eden区(其中包括一个survivor，假如是from)，在一次新生代回收之后，如果对象还存活，并且能够被另外一块survivor所容纳（这里survivor则是to了），则使用复制算法将这些仍然存活的对象复制到to survior区域中，然后清理掉eden和from survivor区域，并将这些存活的对象年龄+1，以后对象在survivor中每熬过一次gc则增加1，当年龄达到某个值时（默认15，通过设置参数-xx:maxtenuringThreshold来设置），这些对象就会成为老年代！但是也不一定，当一些较大的对象（需要分配连续的内存空间）则直接进入老年代。</p>
<ul>
<li>(2) java栈<br>    java栈是一块线程私有的内存空间。如果说，java堆和程序数据密切相关，那么java栈就是和线程执行密切相关。线程执行的基本行为是函数调用，每次函数调用的数据都是通过java栈传递的。<br>java栈与数据结构上的栈有着类似的含义，它是一块先进后出的数据结构，只支持出栈和进栈两种操作，在java栈中保存的主要内容为栈帧。每一次函数调用，都会有一个对应的栈帧被压入java栈，每一个函数调用结束，都会有一个栈帧被弹出java栈。如下图：栈帧和函数调用。函数1对应栈帧1，函数2对应栈帧2，依次类推。函数1中调用函数2，函数2中调用函数3，函数3调用函数4.当函数1被调用时，栈帧1入栈，当函数2调用时，栈帧2入栈，当函数3被调用时，栈帧3入栈，当函数4被调用时，栈帧4入栈。当前正在执行的函数所对应的帧就是当前帧（位于栈顶），它保存着当前函数的局部变量、中间计算结果等数据。当函数返回时，栈帧从java栈中被弹出，java方法区有两种返回函数的方式，一种是正常的函数返回，使用return指令，另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li>
</ul>
<p> 1、局部变量表：是栈帧的重要组成部分之一。它用于保存函数的参数以及局部变量，局部变量表中的变量只在当前函数调用中有效，当函数调用结束，随着函数栈帧的弹出销毁，局部变量表也会随之销毁。<br> 2、操作数栈：它主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。操作数栈也是一个先进后出的数据结构，只支持入栈和出栈两种操作，许多java字节码指令都需要通过操作数栈进行参数传递。<br> 3、除了局部变量表和操作数栈，java栈帧还需要一些数据来支持常量池的解析、正常方法返回和异常处理等。大部分java字节码指令需要进行常量池访问，在帧数据区中保留着访问常量池的指针，方便程序访问常量池。此外，当函数返回或者出现异常时，虚拟机必须恢复调用者函数的栈帧，并让调用者函数继续执行下去。对于异常处理，虚拟机必须有一个异常处理表，方便在发生异常时找到处理异常的代码，因此异常处理表也是帧数据区中重要的一部分。<br><strong>为什么要有堆和栈？这样设计有什么好处？</strong><br>（1）Java自动管理堆和栈，程序员不能直接地设置栈和堆。<br>（2）Java的堆是一个运行时数据区。堆是由JVM的垃圾回收器自动管理的。堆的优势是可以在程序运行时，动态地分配内存<br>大小，但是正是由于这个原因，它的存取速度较慢。<br>（3）栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小和生存期是必须确定的，缺乏灵活性。<br>栈有一个很重要的特性，就是存在栈中的数据可以共享。</p>
<ul>
<li><ol start="4">
<li><strong>方法区</strong><br>    和堆一样，方法区是一块所有线程共享的内存区域，它用于保存系统的类信息，比如类的字段、方法、常量池等。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区的溢出，虚拟机同样会抛出内存溢出错误。 <br>    在JDK1.6、JDK1.7中，方法区可以理解为永久区（Perm）。永久区可以使用参数-XX:PermSize和-XX:MaxPermSize指定，默认情况下，-XX:MaxPermSize为64M。一个大的永久区可以保存更多的类信息。如果系统使用了一些动态代理，那么有可能会在运行时生成大量的类，如果这样，就需要设置一个合理的永久区大小，确保不发生永久区内存溢出。<br>    在JDK1.8中，永久区已经被彻底移除，取而代之的是元数据区，元数据区大小可以使用参数-XX:MaxMetaspaceSize指定（一个大的元数据区可以使系统支持更多的类），这是一块堆外的直接内存。与永久区不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生异常，虚拟机一样会抛出异常。</li>
</ol>
</li>
<li><ol start="5">
<li><strong>类加载机制</strong>(类的加载过程)<br>(1) 加载<br>第一步：获取二进制字节流也就是上面的class文件。<br>第二步：将静态的存储结构转换为方法区中的运行时数据结构。<br>第三步：生成一个对象放入java堆中，做为对方法区的引用。</li>
</ol>
</li>
</ul>
<p>(2) 验证<br>验证主要是检验如下的几项是否正确:<br>   class文件的表示（魔数）<br>   class文件的版本号<br>   class文件的每个部分是否正确（字段表、方法表等）<br>   验证常量池（常量类型、常量类型数据结构是否正确，utf-8是否标准）<br>   元数据验证（父类验证，继承验证，final验证）<br>   字节码（指令）验证<br>   符号引用验证（是否能根据符号找到对应的字段、表、方法等）</p>
<p>(3) 准备<br>准备阶段为类变量分配内存 和设置类变量初始化。这个过程中，只对static类变量进行内存分配，这个时候只是分配内存，没有进行复制，所有的类变量都是初始化值。如果是final的话，会直接对应到常量池中。会在准备阶段直接赋值。</p>
<p>(4) 解析<br>解析阶段是读符号引用进行解析。将符号引用解析为直接引用（指向目标的指针或者偏移量）。主要涉及到的解析有类，接口，字段，方法等。</p>
<p>(5) 初始化<br>初始化就是执行方法的过程， 对静态变量，静态代码块进行初始化，对类进行初始化。</p>
<p>(6) 使用<br>使用阶段就是使用这个class。</p>
<p>(7) 卸载<br>卸载阶段就是不在使用，将class给卸载。</p>
<p><em>JVM实例的消亡</em><br>当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用java.lang.Runtime类或者java.lang.System.exit()来退出。<br>Jython&#x2F;Scala&#x2F;Groovy&#x2F;JRuby都是可以编译成字节码文件的。所以不是java才可以使用java虚拟机</p>
<p><em>java的特性</em><br>Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 。</p>
<h3 id="1-2-2-熟练使用Frida-x2F-Xposed进行Java层动静态方法的hook和主动调用"><a href="#1-2-2-熟练使用Frida-x2F-Xposed进行Java层动静态方法的hook和主动调用" class="headerlink" title="1.2.2 熟练使用Frida&#x2F;Xposed进行Java层动静态方法的hook和主动调用"></a>1.2.2 熟练使用Frida&#x2F;Xposed进行Java层动静态方法的hook和主动调用</h3><h3 id="1-2-3-熟练使用Frida-x2F-Xposed进行hook或构造Java的数据类型和复杂类型"><a href="#1-2-3-熟练使用Frida-x2F-Xposed进行hook或构造Java的数据类型和复杂类型" class="headerlink" title="1.2.3 熟练使用Frida&#x2F;Xposed进行hook或构造Java的数据类型和复杂类型"></a>1.2.3 熟练使用Frida&#x2F;Xposed进行hook或构造Java的数据类型和复杂类型</h3><h3 id="1-2-4-熟练处理面向对象的高级特性如-抽象-内部-类、接口、构造器、多态"><a href="#1-2-4-熟练处理面向对象的高级特性如-抽象-内部-类、接口、构造器、多态" class="headerlink" title="1.2.4 熟练处理面向对象的高级特性如(抽象)(内部)类、接口、构造器、多态"></a>1.2.4 熟练处理面向对象的高级特性如(抽象)(内部)类、接口、构造器、多态</h3><h2 id="1-3-脱壳"><a href="#1-3-脱壳" class="headerlink" title="1.3 脱壳"></a>1.3 脱壳</h2><h3 id="1-3-1-了解并懂得区分一二三代壳的核心原理与主要表现特征"><a href="#1-3-1-了解并懂得区分一二三代壳的核心原理与主要表现特征" class="headerlink" title="1.3.1 了解并懂得区分一二三代壳的核心原理与主要表现特征"></a>1.3.1 了解并懂得区分一二三代壳的核心原理与主要表现特征</h3><p>一代整体型壳：采用Dex整体加密，动态加载运行的机制；<br>二代函数抽取型壳：粒度更细，将方法单独抽取出来，加密保存，解密执行；<br>三代VMP、Dex2C壳：独立虚拟机解释执行、语义等价语法迁移，强度最高。</p>
<p>VMP虚拟机 : 解释执行保护的是映射表，只要心思细、功夫深，是可以将映射表还原的；二代壳函数抽取目前是可以从根本上进行还原的，dump出所有的运行时的方法体，填充到dump下来的dex中去的，这也是fart的核心原理；最后也就是目前我们推荐的几个内存中搜索和dump出dex的Frida工具，在一些场景中可以满足大家的需求。<br>Dex2C(最难的) : 目前是没有办法还原的，只能跟踪进行分析；</p>
<p>逻辑原理就是下面一句话magic.indexOf(“dex”) &#x3D;&#x3D; 0，只要文件头中含有魔数dex，就把它dump下来。</p>
<h3 id="1-3-2-对于Dex和类的解析、加载和执行流程有比较详细的了解"><a href="#1-3-2-对于Dex和类的解析、加载和执行流程有比较详细的了解" class="headerlink" title="1.3.2 对于Dex和类的解析、加载和执行流程有比较详细的了解"></a>1.3.2 对于Dex和类的解析、加载和执行流程有比较详细的了解</h3><h3 id="1-3-3-熟练使用常见脚本进行脱壳，对其脱壳点原理有清晰的认知"><a href="#1-3-3-熟练使用常见脚本进行脱壳，对其脱壳点原理有清晰的认知" class="headerlink" title="1.3.3 熟练使用常见脚本进行脱壳，对其脱壳点原理有清晰的认知"></a>1.3.3 熟练使用常见脚本进行脱壳，对其脱壳点原理有清晰的认知</h3><h3 id="1-3-4-熟练使用常见脱壳工具如Fart-x2F-Youpk并知晓其核心原理"><a href="#1-3-4-熟练使用常见脱壳工具如Fart-x2F-Youpk并知晓其核心原理" class="headerlink" title="1.3.4 熟练使用常见脱壳工具如Fart&#x2F;Youpk并知晓其核心原理"></a>1.3.4 熟练使用常见脱壳工具如Fart&#x2F;Youpk并知晓其核心原理</h3><h2 id="1-4-追踪和定位"><a href="#1-4-追踪和定位" class="headerlink" title="1.4 追踪和定位"></a>1.4 追踪和定位</h2><h3 id="1-4-1-熟练使用Frida-x2F-Xposed进行项目要求功能的开发和定制"><a href="#1-4-1-熟练使用Frida-x2F-Xposed进行项目要求功能的开发和定制" class="headerlink" title="1.4.1 熟练使用Frida&#x2F;Xposed进行项目要求功能的开发和定制"></a>1.4.1 熟练使用Frida&#x2F;Xposed进行项目要求功能的开发和定制</h3><h3 id="1-4-2-掌握脚本语言如JavaScript、Python的基本开发调试和部署"><a href="#1-4-2-掌握脚本语言如JavaScript、Python的基本开发调试和部署" class="headerlink" title="1.4.2 掌握脚本语言如JavaScript、Python的基本开发调试和部署"></a>1.4.2 掌握脚本语言如JavaScript、Python的基本开发调试和部署</h3><h3 id="1-4-3-熟练进行Classloader、类、方法、重载的枚举定位和hook"><a href="#1-4-3-熟练进行Classloader、类、方法、重载的枚举定位和hook" class="headerlink" title="1.4.3 熟练进行Classloader、类、方法、重载的枚举定位和hook"></a>1.4.3 熟练进行Classloader、类、方法、重载的枚举定位和hook</h3><h3 id="1-4-4-对Linux系统的内存、网络、文件、用户、进程等有初步的认识"><a href="#1-4-4-对Linux系统的内存、网络、文件、用户、进程等有初步的认识" class="headerlink" title="1.4.4 对Linux系统的内存、网络、文件、用户、进程等有初步的认识"></a>1.4.4 对Linux系统的内存、网络、文件、用户、进程等有初步的认识</h3><p>安卓Native层的分析和逆向<br>随着开发能力的提高和对抗的升级，NDK编程越来越多的出现在各大厂商及加固的产品中，作为安卓安全工程师，要有Native层的开发和逆向分析能力，掌握C(++)语言及其可执行文件的分析方法，开展项目要求的评估工作。</p>
<p>2.1 C(++)开发<br>2.1.1 熟练掌握C的面向过程思想，掌握指针、函数、数组&#x2F;结构体和内存管理<br>2.1.2 熟练掌握C++的面向对象思想，了解封装、抽象、继承、多态、多线程<br>2.1.3 熟悉掌握常见数据类型、表达式、控制流在内存中ARM指令的展现形式<br>2.1.4 熟悉变量、函数、数组、结构体等指针对象在内存中ARM指令的展现形式</p>
<p>2.2 NDK开发<br>2.2.1 熟悉安卓与ARM处理器的接口、架构及NDK&#x2F;JNI编译流程和原理<br>2.2.2 熟悉JNI的数据类型、命名规则、核心原理及App运行时的执行流程<br>2.2.3 熟悉JNIEnv的原理、结构和作用、创建和释放、在线程中的使用<br>2.2.4 熟悉JNI的Java类、对象、字符串、数组、反射、系统级的操作和使用</p>
<p>2.3 SO文件格式<br>2.3.1 了解安卓与ARM处理器的接口、架构及NDK编译组件常用工具的使用<br>2.3.2 了解llvm编译器对C(++)程序的预处理、编译、汇编和链接的过程<br>2.3.3 了解so文件的格式、区段、符号(导出)表、调试信息等基本信息<br>2.3.4 了解系统链接器对so的装载、解析、链接、绑定、和执行的过程</p>
<p>2.4 hook native<br>2.4.1 熟悉Frida对进程漫游的操作如Memory&#x2F;Process&#x2F;Thread&#x2F;Module<br>2.4.2 熟悉Frida对内存动态反汇编及Patch的操作如Instruction&#x2F;ArmWriter<br>2.4.3 熟悉Frida对符号hook和inline hook的操作模块Interceptor<br>2.4.4 使用Sandhook等第三方框架对so进行持久化hook模块开发</p>
<p>三、安卓系统网络技术<br>安卓手机是一台完整的计算机，其拥有完整的TCP&#x2F;IP四层模型中的软硬件基础设施，安卓安全工程师要从App及系统源码的角度熟悉整个网络框架并进行利用，尤其对HTTP&#x2F;SSL相关的Java&#x2F;Native层框架要非常的精通，藉此展开项目要求的评估工作。</p>
<p>3.1 TCP&#x2F;IP协议分层模型<br>3.1.1 熟悉TCP&#x2F;IP分层模型和基本通信流程分层的判别<br>3.1.2 熟悉IP地址&#x2F;路由控制&#x2F;DNS&#x2F;DHCP&#x2F;NAT等协议技术<br>3.1.3 熟悉TCP&#x2F;UDP及安卓系统中Native&#x2F;Java层相关API<br>3.1.4 熟悉常见应用协议如HTTP&#x2F;SSH&#x2F;FTP&#x2F;SMB&#x2F;IMAP等</p>
<p>3.2 HTTP<br>3.2.1 熟悉HTTP的基本特点&#x2F;通信流程&#x2F;资源定位&#x2F;传输结构<br>3.2.2 熟悉HTTP的状态码&#x2F;包结构&#x2F;Cookie机制&#x2F;认证机制<br>3.2.3 熟悉HTTP的代理机制及其与Socks&#x2F;路由层代理的区别<br>3.2.4 熟悉常见安卓HTTP框架如okhttp&#x2F;了解其底层实现</p>
<p>3.3 SSL<br>3.3.1 熟悉SSL的完整通信流程及中间人抓包的核心原理<br>3.3.2 熟悉非对称加解密的公私钥结合传输密钥的流程及细节<br>3.3.3 熟悉数字机构证书预置手机或浏览器的原因&#x2F;功能&#x2F;操作<br>3.3.4 熟悉SSL给HTTP带来的加密&#x2F;认证&#x2F;完整性保护的核心原理</p>
<p>3.4 从框架层利用网络库<br>3.4.1 熟悉安卓RSA系列API的基本流程及打断其对证书的验证<br>3.3.2 熟悉安卓KeyStore系列API流程和导出完整客户端证书<br>3.3.3 熟悉常见代码绑定框架及从混淆后的代码中解除证书绑定<br>3.3.4 熟悉HTTPS中SSL与HTTP的关系以及从SSL中提取HTTP</p>
<h1 id="四、密码学技术"><a href="#四、密码学技术" class="headerlink" title="四、密码学技术"></a>四、密码学技术</h1><ol>
<li>对称性加密<br>双方使用的同一个密钥，既可以加密又可以解密，这种加密方法称为对称加密，也称为单密钥加密。<br>简单来说就是：加密与解密都是同一个秘钥。<br>优点：通常在消息发送方需要加密大量数据时使用，算法公开，计算量小，加密速度快，加密效率高。<br>缺点：在数据传送前，发送方和接收方必须商定好秘钥，然后 使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘 钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。<br>在对称加密的算法中常用的算法：DES、AES等<br>AES：秘钥长度可以是128、192、256位，即16字节 、24字节、32字节<br>DES:  秘钥长度64位，即8字节</li>
</ol>
<p>对称加密：常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1；对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录，且缺少修改密码的机制；非对称加密</p>
<ol start="2">
<li>非对称性加密<br>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。<br>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。<br>私钥只能由一方保管，不能外泄。公钥可以交给任何请求方。<br>在非对称加密算法中常用的算法有： RSA等<br>优点：安全<br>缺点：速度慢（每次加密的数据量小）</li>
</ol>
<p><strong>非对称加密</strong>：即常见的 <strong>RSA</strong>算法，还包括 <strong>ECC、DH</strong>等算法，算法特点是，密钥成对出现，一般称为公钥（公开）和私钥（保密），公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。</p>
<ol start="3">
<li><strong>散列函数Hash</strong>：常见的有 <strong>MD5、SHA1、SHA256</strong>，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性；在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密；</li>
</ol>
<h2 id="4-1-认证"><a href="#4-1-认证" class="headerlink" title="4.1 认证"></a>4.1 认证</h2><h3 id="4-1-1-熟悉单项散列函数的作用-x2F-原理-x2F-和常见SHA-x2F-MD5系列的源码"><a href="#4-1-1-熟悉单项散列函数的作用-x2F-原理-x2F-和常见SHA-x2F-MD5系列的源码" class="headerlink" title="4.1.1 熟悉单项散列函数的作用&#x2F;原理&#x2F;和常见SHA&#x2F;MD5系列的源码"></a>4.1.1 熟悉单项散列函数的作用&#x2F;原理&#x2F;和常见SHA&#x2F;MD5系列的源码</h3><h3 id="4-1-2-熟悉消息认证码的作用-x2F-原理-x2F-实现和常见HMAC函数的源码"><a href="#4-1-2-熟悉消息认证码的作用-x2F-原理-x2F-实现和常见HMAC函数的源码" class="headerlink" title="4.1.2 熟悉消息认证码的作用&#x2F;原理&#x2F;实现和常见HMAC函数的源码"></a>4.1.2 熟悉消息认证码的作用&#x2F;原理&#x2F;实现和常见HMAC函数的源码</h3><h3 id="4-1-3-熟悉数字签名的作用-x2F-原理-x2F-实现和RSA函数的源码及验证过程"><a href="#4-1-3-熟悉数字签名的作用-x2F-原理-x2F-实现和RSA函数的源码及验证过程" class="headerlink" title="4.1.3 熟悉数字签名的作用&#x2F;原理&#x2F;实现和RSA函数的源码及验证过程"></a>4.1.3 熟悉数字签名的作用&#x2F;原理&#x2F;实现和RSA函数的源码及验证过程</h3><h3 id="4-1-4-熟悉数字证书的作用-x2F-原理-x2F-实现和SSL-x2F-PKI函数的基本流程"><a href="#4-1-4-熟悉数字证书的作用-x2F-原理-x2F-实现和SSL-x2F-PKI函数的基本流程" class="headerlink" title="4.1.4 熟悉数字证书的作用&#x2F;原理&#x2F;实现和SSL&#x2F;PKI函数的基本流程"></a>4.1.4 熟悉数字证书的作用&#x2F;原理&#x2F;实现和SSL&#x2F;PKI函数的基本流程</h3><ol>
<li><p>数字证书的介绍<br> 数字证书是一种权威性的电子文档，它提供了一种在 Internet 上验证身份的方式。 它是由一个权威机构——CA证书授权(Certificate Authority)中心发行的，人们可以在互联网交往中用它来识别对方的身份。即以数字证书为核心的加密技术可以对网络上传输的信息进行加密和解密、数字签名和签名验证，确保网上传递信息的机密性、完整性，以及交易实体身份的真实性，签名信息的不可否认性。当然在数字证书认证的过程中，数字证书认证中心（CA）作为权威的、公正的、 可信赖的第三方，其作用是至关重要的。数字证书也必须具有唯一性和可靠性。</p>
</li>
<li><p>数字证书的原理<br> 数字证书采用公钥密码体制，即利用一对互相匹配的密钥进行加密、解密。每个用户拥有一把仅为本人所掌握的私有密钥（私钥），用它进行解密和签名；同时拥有一把公共密钥（公钥）并可以对外公开，用于加密和验证签名。当发送一份保密文件时，发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密，这样，信息就可以安全无误地到达目的地了，即使被第三方截获，由于没有相应的私钥，也无法进行解密。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。在公开密钥密码体制中，常用的一种是RSA体制。</p>
<p> 用户也可以采用自己的私钥对信息加以处理，由于密钥仅为本人所有，这样就产生了别人无法生成的文件，也就形成了数字签名。采用数字签名，能够确认以下两点：<br> （1）保证信息是由签名者自己签名发送的，签名者不能否认或难以否认；<br> （2）保证信息自签发后到收到为止未曾作过任何修改，签发的文件是真实文件。</p>
</li>
<li><p>数字证书的作用<br> 数字证书可用于发送安全电子邮件、访问安全站点、网上证券、网上招标采购、网上签约、网上办公、网上缴费、网上税务等网上安全电子事务处理和安全电子交易活动。数字证书的格式一般采用X.509国际标准。</p>
</li>
<li><p><strong>TLS&#x2F;SSL工作原理</strong><br>TLS&#x2F;SSL的功能实现主要依赖于三类基本算法：散列函数Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p>
</li>
</ol>
<p><img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/10.png"></p>
<p>TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</p>
<p><strong>一、信息保密性</strong></p>
<p>交易中的商务信息均有保密的要求。帐号和用户名被人知悉，就可能被盗用，订货和付款的信息被竞争对手获悉，就可能丧失商机。而CA中心颁发的数字安全证书保证了电子商务的信息传播中信息的保密。</p>
<p><strong>二、身份确定性</strong></p>
<p>网上交易的双方很可能素昧平生，相隔千里。要使交易成功首先要能确认对方的身份，对商家要考虑 客户端不能是骗子，而客户也会担心网上的商店不是一个玩弄欺诈的黑店。因此能方便而可靠地确认对方身份是交易的前提。对于为顾客或用户开展服务的银行、公司和销售商店，为了做到安全、保密、可靠地开展服务活动，都要进行身份认证的工作。而CA中心颁发的电子签名可保证网上交易双方的身份，银行和公司可以通过CA认证确认身份，放心的开展网上业务。</p>
<p><strong>三、不可否认性</strong></p>
<p>由于商情的千变万化，交易一旦达成是不能被否认的。否则必然会损害一方的利益。例如订购黄金， 订货时金价较低，但收到订单后，金价上涨了，如收单方能否认受到订单的实际时间，甚至否认收到订单的事实，则订货方就会蒙受损失。因此CA中心颁发的数字安全证书确保了电子交易通信过程的各个环节的不可否认性，使交易双方的利益不受到损害。</p>
<p><strong>四、不可篡改性</strong></p>
<p>交易的文件是不可被修改的，如上例所举的订购黄金。供货单位在收到订单后，发现金价大幅上涨了，如其能改动文件内容，将订购数1吨改为1克，则可大幅受益，那么订货单位可能就会因此而蒙受损失。 因此CA中心颁发的数字安全证书也确保了电子交易文件的不可修改性，以保障交易的严肃和公正。</p>
<p>SSL (Secure Sockets Layer) 是用来保障你的浏览器和网站服务器之间安全通信，免受网络“中间人”窃取信息。<br>1.当你的浏览器向服务器请求一个安全的网页(通常是 https:&#x2F;&#x2F;)<br>2.服务器就把它的证书和公匙发回来<br>3.浏览器检查证书是不是由可以信赖的机构颁发的，确认证书有效和此证书是此网站的。<br>4.浏览器使用公钥加密了一个随机对称密钥，包括加密的URL一起发送到服务器<br>5.服务器用自己的私匙解密了你发送的钥匙。然后用这把对称加密的钥匙给你请求的URL链接解密。<br>6.服务器用你发的对称钥匙给你请求的网页加密。你也有相同的钥匙就可以解密发回来的网页了</p>
<ol start="6">
<li><strong>PKI（Public Key Infrastructure）</strong></li>
</ol>
<p>4.2 编码<br>4.2.1 熟悉编码的核心原理以及清晰地明白编码不是加解密<br>4.2.1 熟悉Base系列函数的使用场景&#x2F;原理和实现细节<br>4.2.2 熟悉Url编码系列函数的使用场景&#x2F;原理和实现细节</p>
<h1 id="4-3-密码"><a href="#4-3-密码" class="headerlink" title="4.3 密码"></a>4.3 密码</h1><p><img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/7.png"></p>
<h2 id="4-3-1-熟悉对称加解密的核心原理及常见XOR-x2F-AES-x2F-DES系列的源码"><a href="#4-3-1-熟悉对称加解密的核心原理及常见XOR-x2F-AES-x2F-DES系列的源码" class="headerlink" title="4.3.1 熟悉对称加解密的核心原理及常见XOR&#x2F;AES&#x2F;DES系列的源码"></a>4.3.1 熟悉对称加解密的核心原理及常见XOR&#x2F;AES&#x2F;DES系列的源码</h2><p><code>对称加密是指加密和解密使用相同密钥的加密算法，常见的对称加密算法有DES,DES3,AES加密算法。对称加密由于其加解密速度快，常被用于大量的数据加密场景，还有对传输效率要求高的场景如VPN之间的传输，但是由于其密匙不方便保存，所以适合于内部系统。</code></p>
<p><strong>DES加密算法</strong><br>一种 <em>分组加密</em>算法，<br>通过将输入的明文按64位一组，进行分组加，<br>加密过程分为初始置换明文，分组明文，<br>生成子密匙，密匙与明文加密，<br>经过S盒替，P盒替换，置换后的密文与原32位明文加密。<br><img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/8.png"></p>
<p><strong>AES加密算法</strong><br>AES加密算法是分组加密，<br>每一组是16字节，是目前主流的高级加密算法。<br>主要分为密匙轮询，字节替代，行移动，列混合，密匙加轮…….<br>以上操作重复10次，输出的即是加密的数据.<br>密匙加轮：用密匙与原文进行异或操作，原文是128位，密文也是128位，首先将主密匙与原文进行异或操作，后面再用主密匙生成40位子密匙。<br><img src="/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/9.png"></p>
<h2 id="4-3-2-熟悉分组密码的核心原理及ECB-x2F-CBC-x2F-CFB-x2F-OFB系列的特点和使用"><a href="#4-3-2-熟悉分组密码的核心原理及ECB-x2F-CBC-x2F-CFB-x2F-OFB系列的特点和使用" class="headerlink" title="4.3.2 熟悉分组密码的核心原理及ECB&#x2F;CBC&#x2F;CFB&#x2F;OFB系列的特点和使用"></a>4.3.2 熟悉分组密码的核心原理及ECB&#x2F;CBC&#x2F;CFB&#x2F;OFB系列的特点和使用</h2><h2 id="4-3-2-熟悉非对称加解密的核心原理及RSA公钥加密私钥解密的源码实现"><a href="#4-3-2-熟悉非对称加解密的核心原理及RSA公钥加密私钥解密的源码实现" class="headerlink" title="4.3.2 熟悉非对称加解密的核心原理及RSA公钥加密私钥解密的源码实现"></a>4.3.2 熟悉非对称加解密的核心原理及RSA公钥加密私钥解密的源码实现</h2><h2 id="4-3-4-熟悉PGP-x2F-HTTPS-x2F-SSH等应用中混合使用多种加解密组合方式的细节"><a href="#4-3-4-熟悉PGP-x2F-HTTPS-x2F-SSH等应用中混合使用多种加解密组合方式的细节" class="headerlink" title="4.3.4 熟悉PGP&#x2F;HTTPS&#x2F;SSH等应用中混合使用多种加解密组合方式的细节"></a>4.3.4 熟悉PGP&#x2F;HTTPS&#x2F;SSH等应用中混合使用多种加解密组合方式的细节</h2><h2 id="4-3-5-熟悉秘钥的本质-x2F-安全交换的流程和场景-x2F-如何生成安全的秘钥"><a href="#4-3-5-熟悉秘钥的本质-x2F-安全交换的流程和场景-x2F-如何生成安全的秘钥" class="headerlink" title="4.3.5 熟悉秘钥的本质&#x2F;安全交换的流程和场景&#x2F;如何生成安全的秘钥"></a>4.3.5 熟悉秘钥的本质&#x2F;安全交换的流程和场景&#x2F;如何生成安全的秘钥</h2><h1 id="4-4-从框架层利用密码库"><a href="#4-4-从框架层利用密码库" class="headerlink" title="4.4 从框架层利用密码库"></a>4.4 从框架层利用密码库</h1><h2 id="4-4-1-熟悉安卓MessageDigest系列API的实现流程且导出输入输出"><a href="#4-4-1-熟悉安卓MessageDigest系列API的实现流程且导出输入输出" class="headerlink" title="4.4.1 熟悉安卓MessageDigest系列API的实现流程且导出输入输出"></a>4.4.1 熟悉安卓MessageDigest系列API的实现流程且导出输入输出</h2><p><strong>常用的算法名称有：MD2、MD5、SHA-1、SHA-256、SHA-384、SHA-512</strong></p>
<ol>
<li>MessageDigest介绍<br> MessageDigest 类是一个引擎类，它是为了提供诸如 SHA1 或 MD5 等密码上安全的报文摘要功能而设计的。密码上安全的报文摘要可接受任意大小的输入（一个字节数组），并产生固定大小的输出，该输出称为一个摘要或散列。摘要具有以下属性：<br> 无法通过计算找到两个散列成相同值的报文。<br> 摘要不反映任何与输入有关的内容。<br> 使用报文摘要可以生成数据唯一且可靠的标识符。有时它们被称为数据的“数字指纹”。</li>
</ol>
<p><strong>思路</strong><br>    (1)直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。<br>    (2)x为需要计算的字符串，update传入的参数是字节类型或字节类型数组，对于字符串，需要先使用.<br>    (3)计算消息摘要,执行MessageDigest对象的digest( )方法完成计算，计算的结果通过字节类型的数组返回。<br>    (4)处理计算结果,必要的话可以使用如下代码将计算结果s转换为字符串。<br>    getBytes( )方法生成字符串数组。</p>
<h3 id="4-4-2-熟悉安卓Cipher系列API的实现流程并导出加解密的参数输入输出"><a href="#4-4-2-熟悉安卓Cipher系列API的实现流程并导出加解密的参数输入输出" class="headerlink" title="4.4.2 熟悉安卓Cipher系列API的实现流程并导出加解密的参数输入输出"></a>4.4.2 熟悉安卓Cipher系列API的实现流程并导出加解密的参数输入输出</h3><p><em>Cipher创建</em>：<br>    创建 Cipher 对象，应用程序调用 Cipher 的 getInstance 方法并将所请求转换的名称传递给它。还可以指定提供者的名称（可选）。<br>    转换是一个字符串，它描述为产生某种输出而在给定的输入上执行的操作（或一组操作）。转换始终包括加密算法的名称（例如AES，DES），后面可能跟有一个反馈模式和填充方案。<br><em>Cipher初始化</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> opmode, Key key)</span> <span class="comment">//用密钥初始化此 Cipher。</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">SecretKeySpec</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;密钥&quot;</span>.getBytes(), <span class="string">&quot;AES&quot;</span>); <span class="comment">// 构建密钥</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ENCRYPT_MODE      <span class="comment">//  用于将 Cipher 初始化为加密模式的常量。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> DECRYPT_MODE      <span class="comment">//  用于将 Cipher 初始化为解密模式的常量。</span></span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, key);</span><br></pre></td></tr></table></figure>
<p>    InvalidKeyException- 如果给定的 key 不适合初始化此 Cipher；如果此 Cipher 为解密初始化，并且所需算法参数无法从给定的 key 确定；如果给定 key 的键大小超出所允许的最大值（由已配置的仲裁策略文件确定）。</p>
<p><strong>AES</strong><br>加密关键代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(ALGORITHM_STR); <span class="comment">// 创建密码器</span></span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key);<span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BASE64Encoder</span>().encode(cipher.doFinal(data.getBytes(<span class="string">&quot;utf-8&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>解密关键代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(ALGORITHM_STR);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(<span class="keyword">new</span> <span class="title class_">BASE64Decoder</span>().decodeBuffer(data)), <span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>q0o0p:</p>
<h3 id="4-4-3-熟悉安卓Mac系列API的实现流程并导出加解密的参数输入输出"><a href="#4-4-3-熟悉安卓Mac系列API的实现流程并导出加解密的参数输入输出" class="headerlink" title="4.4.3 熟悉安卓Mac系列API的实现流程并导出加解密的参数输入输出"></a>4.4.3 熟悉安卓Mac系列API的实现流程并导出加解密的参数输入输出</h3><h3 id="4-4-4-熟悉安卓crypto系列API和Native层openssl中常见算法的源码"><a href="#4-4-4-熟悉安卓crypto系列API和Native层openssl中常见算法的源码" class="headerlink" title="4.4.4 熟悉安卓crypto系列API和Native层openssl中常见算法的源码"></a>4.4.4 熟悉安卓crypto系列API和Native层openssl中常见算法的源码</h3><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><p>调试器通过执行“adb forward tcp:<hostport> jdwp:<pid>”命令将host机器上的hostport端口转发到Android上的调试进程，以便调试器通过这个端口连接到目标进程。</pid></hostport></p>
<pre><code>android_server的作用类似于adbd，区别在于，adbd通过本地socket与JDWP进行通信，以转发调试信号；而android_server此处实际上是基于ptrace实现的一个调试器，它一端通过socket与IDA相连接，传输调试指令和数据，另一端通过ptrace直接操控调试进程。
</code></pre>
<p>动态调试android的ndk程序的时候，发现很多程序都会反汇编错误，原来是ARM反汇编的模式没搞对。因为在动态调试的时候，ida Pro并没有去解析elf模块中的一些信息，造成了模块信息丢失，有时候反汇编就会错误。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sub_ 指令和子函数起点</span><br><span class="line">locret_ 返回指令 </span><br><span class="line">loc_ 指令</span><br><span class="line">off_ 数据，包含偏移量</span><br><span class="line">seg_ 数据，包含段地址值</span><br><span class="line">asc_ 数据，ASCII字符串</span><br><span class="line">byte_ 数据，字节（或字节数组）</span><br><span class="line">word_ 数据，16位数据（或字数组）</span><br><span class="line">dword_ 数据，32位数据（或双字数组）</span><br><span class="line">qword_ 数据，64位数据（或4字数组）</span><br><span class="line">flt_ 浮点数据，32位（或浮点数组）</span><br><span class="line">dbl_ 浮点数，64位（或双精度数组）</span><br><span class="line">tbyte_ 浮点数，80位（或扩展精度浮点数）</span><br><span class="line">stru_ 结构体(或结构体数组)</span><br><span class="line">algn_ 对齐指示</span><br><span class="line">unk_ 未处理字节</span><br><span class="line"></span><br><span class="line">LDR&#123;条件&#125;   目的寄存器     &lt;存储器地址&gt;;将存储器地址所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。</span><br><span class="line">LDR R0，[R1，R2]!                                          ；将存储器地址为R1+R2的字数据读入寄存器R0，并将R1+R2的值存入R1。</span><br><span class="line">CMP（比较）指令执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数：</span><br></pre></td></tr></table></figure>
<p>偏移后模块基地址 &#x3D; 偏移前模块基地址 + ASLR偏移</p>
<h1 id="壳的发展"><a href="#壳的发展" class="headerlink" title="壳的发展"></a>壳的发展</h1><h2 id="第一代加固技术—动态加载"><a href="#第一代加固技术—动态加载" class="headerlink" title="第一代加固技术—动态加载"></a>第一代加固技术—动态加载</h2><p>用于保护应用的逻辑不被逆向与分析，主要基于Java虚拟机提供的动态加载技术。</p>
<p>其保护流程是：</p>
<p>开发阶段中将程序切分成加载（Loader）与关键逻辑（Payload）两部分，并分别打包；</p>
<p>运行时加载部分（Loader）会先运行，释放出关键逻辑（Payload），然后java的动态加载技术进行加载，并转交控制权。</p>
<h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><h2 id="填充型抽取壳"><a href="#填充型抽取壳" class="headerlink" title="填充型抽取壳"></a>填充型抽取壳</h2><p>原有CodedeItem空间还在,保证执行前还原填充即可</p>
<h2 id="修改偏移类型抽取壳"><a href="#修改偏移类型抽取壳" class="headerlink" title="修改偏移类型抽取壳"></a>修改偏移类型抽取壳</h2><p>和函数原有偏移空间脱壳关系,执行前修正ARTMethod中的偏移</p>
<hr>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dutlxq2014/article/details/78078734">https://blog.csdn.net/dutlxq2014/article/details/78078734</a><br>jvm:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Strong997/article/details/80023864">https://blog.csdn.net/Strong997/article/details/80023864</a><br>JVM编译过程:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/a550246215/article/details/106164810">https://blog.csdn.net/a550246215/article/details/106164810</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112427083">https://zhuanlan.zhihu.com/p/112427083</a></p>
<p>smali:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41320638/article/details/104504730">https://blog.csdn.net/qq_41320638/article/details/104504730</a><br>xposed hook:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/skillart/article/details/100104649">https://blog.csdn.net/skillart/article/details/100104649</a></p>
<p>脱壳:<br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/197670">https://www.anquanke.com/post/id/197670</a><br>MD5:<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b419163272c1">https://www.jianshu.com/p/b419163272c1</a><br>AES,DES:<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147009696">https://zhuanlan.zhihu.com/p/147009696</a></p>
<p>数字证书:<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/330525206">https://zhuanlan.zhihu.com/p/330525206</a></p>
<p>TLS&#x2F;KPI:<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/103169222">https://zhuanlan.zhihu.com/p/103169222</a> </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">q0o0p</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/">https://github.com/q0o0p-wow/q0o0p-wow.github.io/2021/04/23/reverse-leaning/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/06/mobile-security-top10/"><img class="prev-cover" src="/2021/05/06/mobile-security-top10/undefined" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">移动安全之旅</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/08/java-code-audit/"><img class="next-cover" src="/img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">java代码审计总结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">q0o0p</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">82</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">19</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/q0o0p-wow/q0o0p-wow.github.io"><i class="q0o0p"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#APK"><span class="toc-number">1.</span> <span class="toc-text">APK</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-APK%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 APK文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8Fjar%E3%80%81apk%E3%80%81dex%E3%80%81Manifest%E3%80%81resource%E3%80%81Meta"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 常见文件格式jar、apk、dex、Manifest、resource、Meta</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7Jeb%E3%80%81Jadx%E3%80%81GDA%E3%80%81010editor"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 静态分析工具Jeb、Jadx、GDA、010editor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E7%86%9F%E6%82%89Smali%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E6%95%B0%E6%8D%AE-x2F-%E6%B5%81%E7%A8%8B%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AD%89%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 熟悉Smali语言的指令格式、寄存器、数据&#x2F;流程等操作等指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E5%B9%B6%E6%8E%8C%E6%8F%A1%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%A6%82%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E3%80%81%E6%A0%88%E8%BF%BD%E8%B8%AA%E3%80%81DDMS"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.1.4 配置调试环境并掌握常见的动态调试方法如代码注入、栈追踪、DDMS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Java-hook"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Java hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E4%BA%86%E8%A7%A3JVM%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%A6%82%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E5%A0%86%E6%A0%88%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 了解JVM的基本原理如编译执行流程、虚拟机、内存、堆栈、垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8Frida-x2F-Xposed%E8%BF%9B%E8%A1%8CJava%E5%B1%82%E5%8A%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84hook%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 熟练使用Frida&#x2F;Xposed进行Java层动静态方法的hook和主动调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8Frida-x2F-Xposed%E8%BF%9B%E8%A1%8Chook%E6%88%96%E6%9E%84%E9%80%A0Java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 熟练使用Frida&#x2F;Xposed进行hook或构造Java的数据类型和复杂类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E7%86%9F%E7%BB%83%E5%A4%84%E7%90%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%A6%82-%E6%8A%BD%E8%B1%A1-%E5%86%85%E9%83%A8-%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.2.4 熟练处理面向对象的高级特性如(抽象)(内部)类、接口、构造器、多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%84%B1%E5%A3%B3"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 脱壳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E4%BA%86%E8%A7%A3%E5%B9%B6%E6%87%82%E5%BE%97%E5%8C%BA%E5%88%86%E4%B8%80%E4%BA%8C%E4%B8%89%E4%BB%A3%E5%A3%B3%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%BB%E8%A6%81%E8%A1%A8%E7%8E%B0%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 了解并懂得区分一二三代壳的核心原理与主要表现特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E5%AF%B9%E4%BA%8EDex%E5%92%8C%E7%B1%BB%E7%9A%84%E8%A7%A3%E6%9E%90%E3%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%9C%89%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 对于Dex和类的解析、加载和执行流程有比较详细的了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%84%B1%E5%A3%B3%EF%BC%8C%E5%AF%B9%E5%85%B6%E8%84%B1%E5%A3%B3%E7%82%B9%E5%8E%9F%E7%90%86%E6%9C%89%E6%B8%85%E6%99%B0%E7%9A%84%E8%AE%A4%E7%9F%A5"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 熟练使用常见脚本进行脱壳，对其脱壳点原理有清晰的认知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E8%84%B1%E5%A3%B3%E5%B7%A5%E5%85%B7%E5%A6%82Fart-x2F-Youpk%E5%B9%B6%E7%9F%A5%E6%99%93%E5%85%B6%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4 熟练使用常见脱壳工具如Fart&#x2F;Youpk并知晓其核心原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%BF%BD%E8%B8%AA%E5%92%8C%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 追踪和定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8Frida-x2F-Xposed%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E8%A6%81%E6%B1%82%E5%8A%9F%E8%83%BD%E7%9A%84%E5%BC%80%E5%8F%91%E5%92%8C%E5%AE%9A%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 熟练使用Frida&#x2F;Xposed进行项目要求功能的开发和定制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E6%8E%8C%E6%8F%A1%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%A6%82JavaScript%E3%80%81Python%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%92%8C%E9%83%A8%E7%BD%B2"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 掌握脚本语言如JavaScript、Python的基本开发调试和部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E7%86%9F%E7%BB%83%E8%BF%9B%E8%A1%8CClassloader%E3%80%81%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E9%87%8D%E8%BD%BD%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%BD%8D%E5%92%8Chook"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 熟练进行Classloader、类、方法、重载的枚举定位和hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-%E5%AF%B9Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E3%80%81%E7%BD%91%E7%BB%9C%E3%80%81%E6%96%87%E4%BB%B6%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AD%89%E6%9C%89%E5%88%9D%E6%AD%A5%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4.4 对Linux系统的内存、网络、文件、用户、进程等有初步的认识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF"><span class="toc-number">2.</span> <span class="toc-text">四、密码学技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%AE%A4%E8%AF%81"><span class="toc-number">2.1.</span> <span class="toc-text">4.1 认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%86%9F%E6%82%89%E5%8D%95%E9%A1%B9%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-x2F-%E5%8E%9F%E7%90%86-x2F-%E5%92%8C%E5%B8%B8%E8%A7%81SHA-x2F-MD5%E7%B3%BB%E5%88%97%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">4.1.1 熟悉单项散列函数的作用&#x2F;原理&#x2F;和常见SHA&#x2F;MD5系列的源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%86%9F%E6%82%89%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8-x2F-%E5%8E%9F%E7%90%86-x2F-%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%B8%B8%E8%A7%81HMAC%E5%87%BD%E6%95%B0%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">4.1.2 熟悉消息认证码的作用&#x2F;原理&#x2F;实现和常见HMAC函数的源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E7%86%9F%E6%82%89%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%9A%84%E4%BD%9C%E7%94%A8-x2F-%E5%8E%9F%E7%90%86-x2F-%E5%AE%9E%E7%8E%B0%E5%92%8CRSA%E5%87%BD%E6%95%B0%E7%9A%84%E6%BA%90%E7%A0%81%E5%8F%8A%E9%AA%8C%E8%AF%81%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text">4.1.3 熟悉数字签名的作用&#x2F;原理&#x2F;实现和RSA函数的源码及验证过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E7%86%9F%E6%82%89%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BD%9C%E7%94%A8-x2F-%E5%8E%9F%E7%90%86-x2F-%E5%AE%9E%E7%8E%B0%E5%92%8CSSL-x2F-PKI%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">4.1.4 熟悉数字证书的作用&#x2F;原理&#x2F;实现和SSL&#x2F;PKI函数的基本流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-3-%E5%AF%86%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">4.3 密码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-1-%E7%86%9F%E6%82%89%E5%AF%B9%E7%A7%B0%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E8%A7%81XOR-x2F-AES-x2F-DES%E7%B3%BB%E5%88%97%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">4.3.1 熟悉对称加解密的核心原理及常见XOR&#x2F;AES&#x2F;DES系列的源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-2-%E7%86%9F%E6%82%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%8F%8AECB-x2F-CBC-x2F-CFB-x2F-OFB%E7%B3%BB%E5%88%97%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">4.3.2 熟悉分组密码的核心原理及ECB&#x2F;CBC&#x2F;CFB&#x2F;OFB系列的特点和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-2-%E7%86%9F%E6%82%89%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%8F%8ARSA%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%A7%81%E9%92%A5%E8%A7%A3%E5%AF%86%E7%9A%84%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">4.3.2 熟悉非对称加解密的核心原理及RSA公钥加密私钥解密的源码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-4-%E7%86%9F%E6%82%89PGP-x2F-HTTPS-x2F-SSH%E7%AD%89%E5%BA%94%E7%94%A8%E4%B8%AD%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">3.4.</span> <span class="toc-text">4.3.4 熟悉PGP&#x2F;HTTPS&#x2F;SSH等应用中混合使用多种加解密组合方式的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-5-%E7%86%9F%E6%82%89%E7%A7%98%E9%92%A5%E7%9A%84%E6%9C%AC%E8%B4%A8-x2F-%E5%AE%89%E5%85%A8%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%B5%81%E7%A8%8B%E5%92%8C%E5%9C%BA%E6%99%AF-x2F-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%AE%89%E5%85%A8%E7%9A%84%E7%A7%98%E9%92%A5"><span class="toc-number">3.5.</span> <span class="toc-text">4.3.5 熟悉秘钥的本质&#x2F;安全交换的流程和场景&#x2F;如何生成安全的秘钥</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-4-%E4%BB%8E%E6%A1%86%E6%9E%B6%E5%B1%82%E5%88%A9%E7%94%A8%E5%AF%86%E7%A0%81%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">4.4 从框架层利用密码库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-1-%E7%86%9F%E6%82%89%E5%AE%89%E5%8D%93MessageDigest%E7%B3%BB%E5%88%97API%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E4%B8%94%E5%AF%BC%E5%87%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.1.</span> <span class="toc-text">4.4.1 熟悉安卓MessageDigest系列API的实现流程且导出输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E7%86%9F%E6%82%89%E5%AE%89%E5%8D%93Cipher%E7%B3%BB%E5%88%97API%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E5%B9%B6%E5%AF%BC%E5%87%BA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9A%84%E5%8F%82%E6%95%B0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.4.2 熟悉安卓Cipher系列API的实现流程并导出加解密的参数输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E7%86%9F%E6%82%89%E5%AE%89%E5%8D%93Mac%E7%B3%BB%E5%88%97API%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E5%B9%B6%E5%AF%BC%E5%87%BA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9A%84%E5%8F%82%E6%95%B0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.4.3 熟悉安卓Mac系列API的实现流程并导出加解密的参数输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-4-%E7%86%9F%E6%82%89%E5%AE%89%E5%8D%93crypto%E7%B3%BB%E5%88%97API%E5%92%8CNative%E5%B1%82openssl%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.4.4 熟悉安卓crypto系列API和Native层openssl中常见算法的源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IDA"><span class="toc-number">5.</span> <span class="toc-text">IDA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">5.1.</span> <span class="toc-text">指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B3%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">6.</span> <span class="toc-text">壳的发展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AF%E2%80%94%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.1.</span> <span class="toc-text">第一代加固技术—动态加载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%84%B1%E5%A3%B3"><span class="toc-number">7.</span> <span class="toc-text">脱壳</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E5%9E%8B%E6%8A%BD%E5%8F%96%E5%A3%B3"><span class="toc-number">7.1.</span> <span class="toc-text">填充型抽取壳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%81%8F%E7%A7%BB%E7%B1%BB%E5%9E%8B%E6%8A%BD%E5%8F%96%E5%A3%B3"><span class="toc-number">7.2.</span> <span class="toc-text">修改偏移类型抽取壳</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/12/tensorflow/" title="tensorflow 初使用"><img src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tensorflow 初使用"/></a><div class="content"><a class="title" href="/2026/01/12/tensorflow/" title="tensorflow 初使用">tensorflow 初使用</a><time datetime="2026-01-12T11:48:33.582Z" title="Created 2026-01-12 19:48:33">2026-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/14/smart-television/" title="smart-television"><img src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="smart-television"/></a><div class="content"><a class="title" href="/2022/10/14/smart-television/" title="smart-television">smart-television</a><time datetime="2022-10-14T07:31:32.000Z" title="Created 2022-10-14 15:31:32">2022-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/14/IoT-hardware/" title="IoT-hardware"><img src="/img/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IoT-hardware"/></a><div class="content"><a class="title" href="/2022/10/14/IoT-hardware/" title="IoT-hardware">IoT-hardware</a><time datetime="2022-10-14T06:56:40.000Z" title="Created 2022-10-14 14:56:40">2022-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/01/audio-clip/" title="python 实现简单的音频剪辑"><img src="/2022/08/01/audio-clip/undefined" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python 实现简单的音频剪辑"/></a><div class="content"><a class="title" href="/2022/08/01/audio-clip/" title="python 实现简单的音频剪辑">python 实现简单的音频剪辑</a><time datetime="2022-08-01T01:59:45.000Z" title="Created 2022-08-01 09:59:45">2022-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/19/IoT-Vulnerability/" title="IoT漏洞复现"><img src="/2022/07/19/IoT-Vulnerability/undefined" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IoT漏洞复现"/></a><div class="content"><a class="title" href="/2022/07/19/IoT-Vulnerability/" title="IoT漏洞复现">IoT漏洞复现</a><time datetime="2022-07-19T08:27:13.000Z" title="Created 2022-07-19 16:27:13">2022-07-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/4.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2026 By q0o0p</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script></div><script defer src="https://cdn.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script>
- <script src="https://cdn.jsdelivr.net/gh/Akilarlxh/live2d_demo_without_api@v1.1/assets/jquery.min.js"></script> - <script defer src="https://cdn.jsdelivr.net/gh/Akilarlxh/live2d_demo_without_api@v1.1/assets/jquery-ui.min.js"></script> - <script defer data-pjax src="https://cdn.jsdelivr.net/gh/Akilarlxh/live2d_demo_without_api@v1.1/assets/autoload.js"></script>
<script src="/js/snow_small.js"></script> <script src="/js/fish.js"></script>
<script src="/js/bubble.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d = OML2D.loadOml2d({mobileDisplay:true,models:[{"path":"/live2d-models/live2d-widget/live2d-widget.model.json","scale":0.12,"position":[0,0],"stageStyle":{"width":250,"height":250}}]});</script><!-- hexo injector body_end end --></body></html>